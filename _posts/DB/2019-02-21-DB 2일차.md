---
title:  "DB 2일차!"
read_time: false
share: false
author_profile: false
classes: wide

categories:
  - DataBase
tags:
  - DB
  - OracleDB
---


## table dictionary

tabs는 user_tables의 약어이다. 해당 계정이 가지고 있는 모든 테이블을 출력한다.  
만약 DB안에 있는 모든 테이블을 보고 싶다면 **dba_tables dictionary** 를 사용하면 된다.  
dba_tables 접근권한은 SYS가 가지고 있다.  

`SELECT * FROM dba_tables WHERE OWNER = 'HR';`  
HR 계정에 관한 모든 테이블을 출력한다. (계정 이름 대소문자 구분 필수)  

## user dictionary

1. all_users  
DB의 모든 계정을 출력, (이름, UID, 생성일)  
`SELECT * FROM all_users;`


2. dba_users  
DB의 모든 계정을 출력하는건 all_users와 같지만 출력하는 컬럼 수가 훨씬 많다. 비밀번호는 출력안됨...  
SYS계정에서만 접근할 수 있다.  
`SELECT * FROM dba_users;`

3. user_users
현재 사용자의 관한 정보를 출력  
`SELECT * FROM user_users;`  


# Privilege(권한)

권한이란 SQL 문을 실행하거나, 데이터베이스나 데이터베이스의 객체에 접근할 수 있는 권한을 의미한다.

크게 시스템 권한과 객체 권한으로 나누어져 있는데 사용자에게 어떤 권한이 할당 되어있는지 검색해보자.

1. 사용자에게 부여된 시스템 권한 확인
```sql
SELECT * FROM DBA_SYS_PRIVS
WHERE GRANTEE = 'SCOTT';
```
**UNLIMITED TABLESPACE**는 사용자 생성시 자동으로 부여되는 _시스템 권한_, 객체를 만들 수 있게 해준다.
<br>

2. 사용자에게 부여한 객체(테이블등) 권한 확인
```sql
SELECT * FROM DBA_TAB_PRIVS
WHERE OWNER = 'SCOTT';
```
현재 SCOTT의 EMP테이블에 HR이 SELECT 접근이 가능한 상태이다.
<br>

3. 사용자에게 부여된 롤 확인(시스템 권한이 롤에 포함됨)
```sql
SELECT * FROM DBA_ROLE_PRIVS
WHERE GRANTEE = 'SCOTT';
```


## GRANT 구조

GRANT 시스템권한명 또는 롤명 TO 사용자명 또는 롤명 또는 PUBLIC

`[WITH ADMIN OPTION];`

`WITH ADMIN OPTION` 은 해당 시스템 권한을 다른 사용자나 롤에 재부여를 허용

###### PUBLIC 은 모든 사용자에게 권한을 주기 위한 것으로 권한을 주는 쪽은 신중해야 한다. PUBLIC으로 선언된 권한

###### 은 이 후에 새로 생성된 사용자에게도 자동으로 해당 권한이 부여되기 때문이다.

hr 계정에서 scott 계정의 emp 테이블을 select 할 수 있도록 권한 설정
**GRANT SELECT ON emp TO HR;**


#### PUBLIC Synonym 생성하는법

all_users는 sys계정이 아니더라도 어떤 계정이던 접근 가능하다. GRANT 명령으로 public으로 접근권한이 부여
되어 있기 때문이다.

public으로 인해 다른계정에서 접근하는 것 이해가 되는데 SYS계정 소유의 테이블, dictionary인데 “스키마명.
객체명” 형식으로 사용하지 않는다.
이는 해당 테이블에 PUBLIC synonym이 설정되어 있기 때문. 계속 스키마 명을 쓰는게 번거롭기 때문에 사용.
**PUBLIC Synonym 생성하는법**
1) SYSTEM 권한으로 접속한다.
2) PUBLIC 옵션을 사용하여 시노님을 생성한다.
3) 생성된 시노님에 대해 객체 소유자로 접속한다.
4) 시노님에 권한을 부여한다.
CREATE [PUBLIC] SYNONYM [schema.]synonym명
FOR [schema.]object명;

**CREATE PUBLIC SYNONYM pub_test
FOR kim.test;**
kim.test에 대해 public 시노님(pub_test)을 생성. 이제 kim.test 객체는 모든 사용자가 pub_test라는 이름으로
접근 가능하다.


## 오라클의 연산자(Operator)

###### 비교연산자

#### 비교연산자 설명 USER IS "HR"

#### = 같다 SQL> select * from employees

#### where salary = 2500;

#### !=,

#### ^=,

#### <>

#### 같지 않다 SQL> select * from employees

#### where salary != 2500;

#### <,

#### >

#### 작거나 크다 SQL> select * from employees

#### where salary < 2500;

#### SQL> select * from employees

#### where salary => 2500;

#### ANY,

#### SOME

#### 목록중의 어떤 값과 비교하며,

#### =, !=, >, <, <=, >=가

#### 먼저 선행되어야 함

#### SQL> select * from employees

#### where salary = ANY

#### (SELECT salary from employees

#### where department_id = 30);

#### ALL 목록중의 각각의 값과 비교하며,

#### =, !=, >, <, <=, >=가

#### 먼저 선행되어야 함

#### SQL> select * from employees

#### where salary >= ALL(1400,3000);

###### 비교연산의 결과는 TRUE, FALSE, NULL(UNKNOWN)을 반환한다. NULL 반환?

###### 같지 않는지 검사하는 연산자가 3 개나 되는데 이른 DB별로 사용법이 달라서 추가하다 보니 3 개가 되었다.

###### SELECT *

**FROM emp
WHERE SAL != 1300 and SAL != 1250 and SAL != 1600;**
오라클에선 &&을 and로 사용.

**SELECT *
FROM emp
WHERE DEPTNO = 30 AND SAL NOT BETWEEN 1000 AND 2000;**

**SELECT *
FROM emp
WHERE DEPTNO = 30 AND NOT(sal >=1000 and sal<=2000);**


#### SQL 연산자

```
[NOT] IN (list) list 값중의 하나와 일치
```
- Data type(varchar2, char, number, date)도 사용 가능
- 문자, 날짜 사용시 단일 인용부호('')를 사용해야 함
[NOT] BETWEEN a AND b a와 b 사이 값
- 자기 자신의 값까지 포함한 결과를 출력
- b가 a보다 커야 함
[NOT] LIKE 문자 형태 일치(%, _ 사용)
% 문자의 갯수에 상관 없음(문자열 모두 찾기 *와 비슷)
_ 한 개의 문자를 대신(한 문자 찾기 ?와 비슷)
- 문자나 숫자 포함
- 검색 string 값에 대한 wildcard(%,_)사용
- 문자 패턴 일치 검색
- wildcard를 일반 문자처럼 쓰고 싶은 경우에는 ESCAPE 옵션을 사용
IS [NOT] NULL NULL 값의 유무
- column이 완전히 비어 있으면 null임
- ''(공백),0(zero)과는 다른 값임
- null은 아직 정해지지 않은 값, 계산 될 수 없는 값을 의미
- 있다, 없다의 값을 비교할 때는 IS NULL, IS NOT NULL을 사용
ANY, SOME where 절의 subquery에 쓰임
ALL where 절의 subquery에 쓰임
EXISTS where 절의 subquery에서 값이 존재하면 TRUE를 반환

#### 오라클에서 산술 연산하기

###### SELECT DISTINCT 5+

**FROM dept;**
귀찮은 방법.... Dept의 행 개수만큼 출력을 막기위해 DISTINCT 키워드 사용.....

이럴 땐 SYS의 dual 테이블을 쓰면 좋다.

###### SELECT 5+5, 5-4, 5*3, 5/2, MOD(5,2), TRUNC(5/2)

#### FROM dual;

DUAL이라는 테이블은 SYS 사용자가 소유하는 오라클의 표준 테이블로서 오직 한 행(row)에 한 컬럼만 담고 있는
dummy 테이블로서 일시적인 산술연산이나 날짜 연산을 위하여 주로 쓰인다.
**SELECT current_date, sysdate
FROM dual;**

#### 오라클에서 NULL

**SELECT EMPNO,ENAME,JOB,MGR,HIREDATE, SAL+COMM as "월급",DEPTNO
FROM emp;**


###### 오라클에선 NULL도 데이터(중요한)의 일종이다.

빈 값이나 0 이 아닌 Unknown값 또는 무한대를 의미한다. 따라서 연산이나 비교, 할당이 불가능하다.

따라서 NULL을 다른값으로 바꿔서 연산해 줘야 하는데 오라클 내장 function을 사용해보자.
오라클엔 다양한 함수들이 있다. 여기서 NULL과 관련된 함수는 아래 5 가지. 우리가 쓸건 NVL
**NULL Related 함수**
COALESCE 나열된 값중에서 첫번째 NULL이 아닌 값을 출력
LNNVL where절의 조건이 false이면 TRUE, true이면 FALSE를 반환
NULLIF 첫번째 값과 두번째 값을 비교하여 두 값이 같으면 NULL을 출력하고, 같지 않으면
첫번째 값을 출력
**NVL** 정의한 컬럼이 NULL이면 지정한 값으로 대체
NVL2 함수에 사용된 3 개의 값중 첫 번째 값이 NULL값이 아니면 두 번째 값을 출력하
고, 첫 번째 값이 NULL이면 세 번째 값을 출력

###### NVL과 NVL2로 NULL값을 0 으로 치환

**SELECT EMPNO,ENAME,JOB,MGR,HIREDATE, SAL+NVL(COMM, 0) as "월급",DEPTNO
FROM emp;**

**SELECT EMPNO,ENAME,JOB,MGR,HIREDATE, NVL2(COMM, COMM+SAL, 0) "월급", DEPTNO
FROM emp;**

###### SQL 연산중 IS NULL을 WHERE에 사용하면 조건으로 NULL을 검사할 수 있다.

###### SELECT EMPNO,ENAME,JOB,MGR,HIREDATE, SAL, COMM, DEPTNO

**FROM emp
WHERE COMM IS NULL;**

**SELECT EMPNO,ENAME,JOB,MGR,HIREDATE, SAL, COMM, DEPTNO
FROM emp
WHERE COMM IS NOT NULL;**


###### 잡다구리

**SELECT empno, ename, sal, nvl(comm, 0) nvl_comm
FROM emp
WHERE nvl_comm != 0;**

오류가 나는 이유....
WHERE 실행순서가 SELECT보다 빠르기 때문

##### 절 순서

##### WITH 1

##### SELECT 6

##### FROM 2

##### WHERE 3

##### GROUP BY 4

##### HAVING 5

##### ORDER BY 7

##### 절마다 각각 개행하고, 순서 지켜야 유지보수가 편하다

###### CREATE로 계정을 만들었다면 DROP로 삭제할 수 있다.

**DROP USER gildong;
DROP USER gildong cascade;**
계정뿐만 아니라 그 계정이 만든 테이블, 스키마 전체를 삭제한다.


