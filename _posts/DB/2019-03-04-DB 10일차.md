---
title:  "DB 10일차!"
header:
  overlay_image: /assets/DB/dbimage.jpg
  caption: "Photo credit: [**oracle**](https://www.oracle.com)"

read_time: false
share: false
author_profile: false
classes: wide

categories:
  - DataBase
tags:
  - DB
  - OracleDB

toc: true

---

# JOIN

같거나 서로 다른 두 개 이상의 테이블에서 컬럼을 검색할 때 사용한다. 이때, where절에 join 조건을 작성하여 테이블을 연결한다.

## JOIN 종류

<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-zlqz{font-weight:bold;background-color:#c0c0c0;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 855px">
<colgroup>
<col style="width: 190px">
<col style="width: 238px">
<col style="width: 427px">
</colgroup>
  <tr>
    <th class="tg-zlqz">JOIN 분류</th>
    <th class="tg-zlqz">ORACLE 지원</th>
    <th class="tg-zlqz">동작설명<br></th>
  </tr>
  <tr>
    <td class="tg-zlqz">CROSS JOIN</td>
    <td class="tg-0pky">CROSS JOIN</td>
    <td class="tg-0pky">Cartesian Product로 실행</td>
  </tr>
  <tr>
    <td class="tg-zlqz" rowspan="3">EQUI JOIN</td>
    <td class="tg-0pky">EQUI JOIN (where절에 '='사용)</td>
    <td class="tg-0pky">where 절의 조건에 '='를 사용함</td>
  </tr>
  <tr>
    <td class="tg-0pky">NATURAL JOIN</td>
    <td class="tg-0pky">match되는 컬럼에 대해 모두 product 실행</td>
  </tr>
  <tr>
    <td class="tg-0pky">JOIN...USING(컬럼)</td>
    <td class="tg-0pky">match되는 컬럼중 지정한 컬럼에 대해서만 product 실행</td>
  </tr>
  <tr>
    <td class="tg-zlqz" rowspan="2">NON-EQUI JOIN</td>
    <td class="tg-0pky">non-EQUI JOIN</td>
    <td class="tg-0pky">'='를 사용함</td>
  </tr>
  <tr>
    <td class="tg-0pky">JOIN ∼ ON BETWEEN a AND b</td>
    <td class="tg-0pky">JOIN절에 JOIN하고자 하는 table을 기술하고 ON절에 비교하고자 하는 범위를 지정</td>
  </tr>
  <tr>
    <td class="tg-zlqz" rowspan="3">OUTER JOIN</td>
    <td class="tg-0pky">RIGHT [OUTER] JOIN ... ON</td>
    <td class="tg-0pky">FROM절 오른쪽에 위치한 테이블이 NULL을 가진 경우</td>
  </tr>
  <tr>
    <td class="tg-0pky">LEFT [OUTER] JOIN ... ON</td>
    <td class="tg-0pky">FROM절 왼쪽에 위치한 테이블이 NULL을 가진 경우</td>
  </tr>
  <tr>
    <td class="tg-0pky">FULL [OUTER] JOIN ... ON</td>
    <td class="tg-0pky">left outer join과 right outer join을 동시에 실행한 것과 같은 결과를 출력</td>
  </tr>
  <tr>
    <td class="tg-zlqz" rowspan="2">SELF JOIN</td>
    <td class="tg-0pky">방법1) SELF JOIN</td>
    <td class="tg-0pky" rowspan="2">하나의 테이블을 alias하여 다른 두 개의 테이블처럼 사용</td>
  </tr>
  <tr>
    <td class="tg-0pky">방법2) JOIN ∼ ON</td>
  </tr>
  <tr>
    <td class="tg-zlqz">ANTI JOIN</td>
    <td class="tg-0pky">NOT IN</td>
    <td class="tg-0pky">서브쿼리한 결과 속에 없는 컬럼</td>
  </tr>
  <tr>
    <td class="tg-zlqz">SEMI JOIN</td>
    <td class="tg-0pky">EXISTS</td>
    <td class="tg-0pky">서브쿼리한 결과 속에 있는 컬럼</td>
  </tr>
</table>

 
## EQUI JOIN

두 개 이상의 테이블에 관계되는 컬럼들의 값들이 일치하는 경우에 사용하는 가장 일반적인 join 형태.  
WHERE 절에 `=`(등호)를 사용한다.
흔히 primary key, foreign key 관계를 이용한다.  

EQUI JOIN은 아래 4가지 방식을 통해 쿼리를 만들 수 있다.  

### WHERE조건 사용하기 
```sql
SELECT dname, e.ename
FROM dept d, emp e
WHERE d.deptno = e.deptno;
```
테이블에 별칭사용하서 칼럼을 지정가능하다. 중복되는 칼럼은 테이블명을 `.`을 앞에 붙여야하기 때문에 별칭을 사용하면 편한다.  


### JOIN ON 사용하기
```sql
SELECT dname, ename
FROM dept d JOIN emp e
ON d.deptno = e.deptno;
```

### USING() 사용하기
```sql
SELECT dname, ename
FROM dept JOIN emp
USING(deptno);
```
using문 안에는 별칭을 쓸 수 없다.

### NATURAL JOIN 사용하기
```sql
SELECT dname, ename
FROM dept
NATURAL JOIN emp;
```
![image1]({{ "/assets/DB/days10/image1.png" | absolute_url }}){: .shadow}  

모두 같은결과 출력
 

부서번호가 30반인 사원 정보를 조회(조건추가)  

왠지 WHERE조건에 JOIN조건을 넣어서 다른 조건을 추가하기 힘들것 같지만 그냥 AND연산자 쓰면 된다.   
```sql
-- =(등호) 사용하기
SELECT dname, e.ename
FROM dept d, emp e
WHERE d.deptno = e.deptno AND d.deptno = 30;

-- JOIN ON 사용하기
SELECT dname, ename
FROM dept d JOIN emp e
ON d.deptno = e.deptno
WHERE d.deptno = 30;

-- JOIN USING 사용하기
SELECT dname, ename
FROM dept JOIN emp
USING(deptno)
WHERE deptno = 30;

-- NATURE JOIN 사용하기
SELECT dname, ename
FROM dept
NATURAL JOIN emp
WHERE deptno = 30;
```

 
 
위의 테이블에서 
책ID, 책제목, 판매수량, 단가, 서점명, 판매금액을 JOIN을 통해 조회해보자.

b_id(책ID): book(PK), panmai, danga, au_book(FK)
title: book
p_su(판매수량) : panmai
price(단가): danga
g_name(서점명): gogaek

판매수량 * 책가격(판매금액): p_su * price
>없는 속성을 추출해서 만든 것을 추출속성이라 한다.

SELECT b_id, title
FROM book;
 
일단 책ID와 제목은 출력된다,
 

SELECT b.b_id, title, p_su
FROM book b, panmai p
WHERE b.b_id = p.b_id;
 
판매테이블과 JOIN을 통해 판매 수량도 알아옴


SELECT b.b_id, title, p_su, price
FROM book b, panmai p, danga d
WHERE b.b_id = p.b_id AND b.b_id = d.b_id;
 
테이블을 2개이상 가져와도 문제 없다!

 
SELECT b.b_id, title, p_su, price, g_name, p_su*price AS 판매금액
FROM book b, panmai p, danga d, gogaek g
WHERE b.b_id = p.b_id AND b.b_id = d.b_id AND g.g_id = p.g_id;
 

JOIN사용해서 다시 쿼리
SELECT b.b_id, title, p_su, price, g_name, p_su*price AS 판매금액
FROM book b 
JOIN panmai p ON b.b_id = p.b_id
JOIN danga d ON b.b_id = d.b_id 
JOIN gogaek g ON g.g_id = p.g_id;
 
USING사용해서 다시 쿼리
SELECT b_id, title, p_su, price, g_name, p_su*price AS 판매금액
FROM book
JOIN panmai USING(b_id)
JOIN danga USING(b_id)
JOIN gogaek USING(g_id);

왠만하면 JOIN… ON…을 쓰는 것이 좋다.
 
NON-EQUI JOIN

관계되는 컬럼이 정확히 일치하지 않는 경우에 사용되는 JOIN의 형태이다.
EQUI JOIN에선 등위 연산자를 통해 같은 값에 해당하는 엔트리만 출력했지만
NON EQUI JOIN에선 BETWEEN, > 연산자 등을 사용해 포함되는 엔트리를 출력한다.

WHERE 절에 BETWEEN ... AND ... 연산자를 사용한다.
오라클에서는 ON 절을 이용하여 NON-EQUI JOIN과 동일한 역할을 수행한다.

형식
SELECT 테이블1명.컬럼명, 테이블2명.컬럼명
FROM 테이블1, 테이블2명
WHERE 테이블1명.컬럼명 BETWEEN 테이블2명.컬럼명 AND 테이블2명.컬럼명


SELECT e.ename, e.sal, s.grade
FROM emp e, salgrade s
WHERE e.sal BETWEEN s.losal AND s.hisal;
 

 
SELF JOIN

한 개의 테이블을 두 개의 테이블처럼 사용하기 위해 
테이블 별명을 사용하여 한 테이블을 자체적으로 JOIN하여 사용한다.
SELF JOIN은 테이블이 자신의 특정 컬럼을 참조하는 또 다른 하나의 컬럼을 가지고 있는 경우에 사용한다.

SELECT deptno, ename, empno, mgr
FROM emp
 
mgr칼럼은 은 사수의 empno이다. 
mgr말고 사수의 이름까지 출력하고 싶다면 SELF JOIN을 사용하면 된다.


SELECT a.deptno, a.ename, a.empno, a.mgr, b.ename 
FROM emp a 
JOIN emp b ON a.mgr = b.empno;
 
이퀄 조인과 같은 방식이지만 그냥 같은 테이블끼리 JOIN했기에 SELF JOIN이라 부른다.
 
CROSS JOIN

Cartesian Product(집합의 곱)를 실행한 것과 같은 결과를 출력한다.
테이블 aa와 bb를 CROSS JOIN할 때 각 테이블의 행 수가 각각 3, 2 이라면 출력 결과는 3x2=6가 출력된다.

SELECT *
FROM emp, dept;

조인 조건 없이 조인하면 된다. 이렇게 사용할 일 거의 없음.


ANTIJOIN
서브쿼리한 결과 속에 해당 컬럼이 존재하지 않는 경우로 NOT IN을 사용함

select employee_id, first_name, last_name, manager_id, department_id
from employees
where department_id NOT IN
(select department_id from departments where location_id = 1700);




SEMIJOIN
서브쿼리한 결과 속에 해당 컬럼이 존재하는 경우로 EXISTS을 사용함

select last_name, department_id from employees
where department_id IN
(select department_id from employees where last_name = 'Lorentz');

둘 다 EQUI JOIN의 연장선이지만 사용 방식에 따라 부르는 이름이 다를뿐이다.
 
OUTER JOIN

SELECT *
FROM emp, dept
ORDER BY emp.empno;

SELECT * FROM emp;

--dept테이블에 있는 deptno에 해당하는 사원 수를 구하고 싶다
--GROUP BY로 구하면 된다 물론
--하지만 아직 사원이 없는 부서의 사원수까지 구하고 싶다면?
--emp테이블 사원중에 40번 부서에 해당하는 사원은 없다.
--사원 없는 부서의 데이터까지 출력하고 싶다면 OUTER JOIN을 써야한다.

SELECT dept.deptno, COUNT(emp.deptno)
FROM emp RIGHT OUTER JOIN dept ON emp.deptno = dept.deptno
GROUP BY dept.deptno;

--사실 지금까지 JOIN앞에는 INNER가 생략된 것이였다. 
--RIGHT를 붙임으로 조건을 만족하지 않더라도 오른쪽 테이블의 행을 모두 출력한다.


SELECT dept.deptno, COUNT(emp.deptno)
FROM emp, dept
WHERE emp.deptno(+) = dept.deptno
GROUP BY dept.deptno;
--위와 같은 OUTER JOIN이다. +기호를 통해서도 가능하다.
 
잡다구리
EXISTS

SELECT b.b_id, title, price
FROM book b
JOIN danga d ON(b.b_id = d.b_id)
WHERE b.b_id NOT IN(SELECT b_id FROM panmai);


SELECT b.b_id, title, price
FROM book b
JOIN danga d ON(b.b_id = d.b_id)
WHERE NOT EXISTS(SELECT b_id FROM panmai WHERE b_id = b.b_id);
 
