---
title:  "Java - JDBC 6일차!"

read_time: false
share: false
author_profile: false
classes: wide

categories:
  - jdbc

tags:
  - database
  - java

toc: true

---

## JDBC Connection Pooling, Connection Factory 

데이터베이스의 처리에서 가장 많은 시간을 필요로 하는 부분은 데이터베이스의 로그인 부분이다.

jdbc 프로그래밍 하다보면 가장 오래걸리는 부분이 DBConn.getConnection함수 호출부분이란걸 알 수 있다..

컨넥션 풀링을 사용하면 미리 연결 해놓고 기다릴 필요 없다.

프로그래밍 시작할 때 미리 컨넥션(Connection)을 여러 개 개설한 뒤 필요할 때 만들어 둔 컨넥션을 사용하는 기법을 컨넥션 풀링이라 한다.

빠른 연결을 위한 Connection Pooling과 Connection Factory를 알아보자.  


### Connection Factory  

image19

원래는 바로 DB에서 Oracle클래스와 DriverManager를 통해 Connetion객체를 가져왔는데 ConnFactory 클래스를 통해 Connection을 가져온다. 
우리가 전에 만든 DBConn클래스와 거의 비슷하다.

앞으로 ~Factory 라는 클래스가 만은데 대부분 앞에 붙은 객체를 생성해서 반환해주는 클래스이다.  

```java
public static void main(String[] args) throws IOException {
  Properties p = new Properties();
  p.put("Driver","oracle.jdbc.driver.OracleDriver");
  p.put("URL","jdbc:oracle:thin:@172.17.107.68:1521:xe");
  p.setProperty("MaxConn","10");
  p.setProperty("User","scott");
  p.setProperty("Password","tiger");
  
  FileOutputStream out = new FileOutputStream(".\\src\\days06\\jdbc.properties");
  p.store(out,"JDBC Config Setting");
  out.close();
}
```

그럼 days06에 다음과 같이 jdbc.properties 파일이 생긴다.  
```
#JDBC Config Setting
#Mon Mar 25 10:07:04 KST 2019
URL=jdbc\:oracle\:thin\:@172.17.107.68\:1521\:xe
Password=tiger
Driver=oracle.jdbc.driver.OracleDriver
User=scott
MaxConn=10
```

```java
public class PracticeConnFactpry {
	public static void main(String[] args) {
		ConnFactory factory = ConnFactory.getDefaultFactory();
		Connection conn = factory.createConnection();
		Statement stmt;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM emp");
			while (rs.next()) {
				System.out.println(rs.getString("ename"));
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}

class ConnFactory{
	private static int maxconn = 0;
	private static String url = null;
	private static String driver = null;
	private static String user = null;
	private static String password = null;
	private static ConnFactory connFactory = new ConnFactory();
	static{
		try{
			loadProperties(".\\src\\days06\\jdbc.properties");
		}catch(IOException e){
			System.out.println("jdbc.properties ............");
			e.printStackTrace();
		}
	}
	private ConnFactory() {}; //싱글톤
	public Connection createConnection() {
		Connection conn = null;
		try {
			Class.forName(driver);
			conn = DriverManager.getConnection(url, user, password);
		} catch (SQLException | ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return conn;
	}
	public static ConnFactory getDefaultFactory() {
		if(connFactory == null)
			connFactory = new ConnFactory();
		return connFactory;
	}
	private static void loadProperties(String fileName) throws IOException {
		Properties p = new Properties();
		FileInputStream in = new FileInputStream(fileName);
		p.load(in);
		in.close();
		url = p.getProperty("URL");
		driver = p.getProperty("Driver");
		user = p.getProperty("User");
		password = p.getProperty("Password");
		maxconn = Integer.parseInt(p.getProperty("MaxConn"));
	}
	public static int getMaxConn(){
		return maxconn;
	}
}
```

이제 Factory에서 맨처음에만 Connection객체를 만들어두고 다른 프로그램에서 만들어진 Connection객체를 가져와서 사용하면 된다.




### Connection Pooling

미리 컨넥션을 일정 수만큼 생성시킨 뒤 컨넥션을 빌려주고 다시 반환받는 형식으로 컨넥션을 관리한다.   
image20  

컨넥션 풀에서 필요한 만큼 Connection을 미리 생성  
Connection이 필요할 때 컨넥션 풀에서 빌려서 사용  
사용이 끝난 다음에는 Connection을 컨넥션 풀에 반환  

```java
public class PracticeConnPool {
	public static void main(String[] args) throws InterruptedException {
		ConnPool pool = ConnPool.getConnPool();
		Connection conn = pool.getConnection();
		Statement stmt;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM emp");
			while (rs.next()) {
				System.out.println(rs.getString("ename"));
			}
			rs.close();
			stmt.close();
			pool.releaseConnection(conn);
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
} 
class ConnPool{
	
	private Vector<Connection> buffer = new Vector<>();
    private static ConnPool connPool = new ConnPool();
    static {
    	initConnPool();
    }
    private ConnPool(){} //싱글톤
    private static void initConnPool() {
    	destroyConnPool();
    	Vector<Connection> temp = ConnPool.getConnPool().getConnPoolBuffer();
    	ConnFactory factory = ConnFactory.getDefaultFactory();
    	for (int i = 0; i < ConnFactory.getMaxConn(); i++) {
			Connection conn = factory.createConnection();
			temp.addElement(conn);
			System.out.println("NewConnection Created.."+conn);
		}
	}
	private static void destroyConnPool() {
		Vector<Connection> temp = ConnPool.getConnPool().getConnPoolBuffer();
		Enumeration<Connection> en = temp.elements();
		while (en.hasMoreElements()) {
			Connection conn = (Connection) en.nextElement();
			if(conn != null) {
				try {
					conn.close();
					System.out.println("Connection Closed.."+conn);
				} catch (SQLException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}
	}
	private Vector<Connection> getConnPoolBuffer() {
		return this.buffer;
	}
	public static ConnPool getConnPool(){
        if(connPool == null){
            connPool = new ConnPool();
        }
        return connPool;
    }
    public synchronized Connection getConnection() throws InterruptedException
    {
    	while (this.buffer.size() == 0) {
			this.wait();
		}
    	Connection conn = this.buffer.remove(this.buffer.size()-1); //맨끝의 Connection 대여
    	System.out.println("Connection 대여 getConnection()"+conn);
    	return conn;
    }
    public synchronized void releaseConnection(Connection conn)
    {
    	this.buffer.addElement(conn);
    	System.out.println("Connection 반환 releaseConnection()"+conn);
    	this.notifyAll();
    }
}
```

