---
title:  "JSP/Servlet - EL, JSTL!"

read_time: false
share: false
author_profile: false
classes: wide

categories:
  - JSP

tags:
  - JSP
  - servelt

toc: true

---

## EL(Expression Language)

jsp에서 자바코딩을 **좀더 간결하게** 하기 위해 사용되는 언어,  

다음과 같은 기능을 제공한다.  

* JSP 네가지 기본 객체(`request`, `response`)가 제공하는 영역의 속성 사용

* 수치연산, 관계연산, 논리연산자 제공

* 자바클래스, 메서드 호출기능 제공

* 쿠키, 기본객체의 속성 등 JSP를 위한 표현언어의 기본객체 제공

* 람다식을 이용한 함수 정의와 실행

EL은 `${ expr }`형식으로 사용한다.  
`$`달러 기호와 `{}`대괄호가 `EL`스크립트임을 표시한다.  

EL에선 다음 5가지의 데이터 타입이 존재한다.  
**Boolean, 정수, 실수, 문자열, Null타입**  

**기본 객체**|**설 명**
:-----:|:-----
`pageContext`|JSP의 page 기본 객체와 동일하다.
`pageScope`|`pageContext` 기본 객체에 저장된 속성의 <속성, 값> 매핑을 저장한 `Map` 객체
`requestScope`|`request` 기본 객체에 저장된 속성의 <속성, 값> 매핑을 저장한 `Map` 객체
`sessionScope`|`session` 기본 객체에 저장된 속성의 <속성, 값> 매핑을 저장한 `Map` 객체
`applicationScope`|`application` 기본 객체에 저장된 속성의 <속성, 값> 매핑을 저장한 `Map` 객체
`param`|요청 파라미터의 <파라미터이름, 값> 매핑을 저장한 `Map` 객체. 파라미터 **값의 타입은 `String`으로서,** `request.getParameter(이름)`의 결과와 동일하다.
`paramValues`|요청 파라미터의 <파라미터이름, 값배열> 매핑을 저장한 `Map` 객체. **값의 타입은 `String[]`으로서,** `request.getParameterValues(이름)`의 결과와 동일하다.
`header`|요청 정보의 <헤더이름, 값> 매핑을 저장한 `Map` 객체, `request.getHeader(이름)`의 결과와 동일하다.
`headerValues`|요청 정보의 <헤더이름, 값 배열> 매핑을 저장한 `Map` 객체. `request.getHeaders(이름)`의 결과와 동일하다.
`cookie`|<쿠키 이름, Cookie> 지정한 `Map` 객체. `request.getCookies()`로 구한 Cookie배열로부터 매핑을 생성한다.
`initParam`|초기화 파라미터의 <이름, 값> 매핑을 저장한 `Map` 객체, `application.getInitParameter(이름)`의 결과와 동일하다.


## JSTL

스트립트릿, 표현부를 `if`문, `while`문등 조건문과 같이 사용하면 코드가 지저분하고 유지보수하기 힘들어 진다.  

이를 해결하기 위해 `JSTL`(표준 태그 라이브러리)을 사용한다.  
직관적이고 간결한 코드를 제공한다.  

JSTL을 사용하기 위해 라이브러리를 받아야 하는데 아래 주소에서 다운 가능하다.

>https://search.maven.org/artifact/jstl/jstl/1.2/jar  

다운받아 jdbc드라이버와 같이 `WEB-INF/lib/`위치에 저장하면 된다.  


JSTL에서 제공하는 태그의 종류는 **코어, XML, 국제화, 데이터베이스, 함수** 등의 태그가 있지만  
변수지원, 흐름제어 역할을 하는 **코어태그**에 대해 먼저 알아보자.  

코어태그 라이브러리를 사용하려면 `html`태그 위에 다음과 같은 **`taglib`디렉티브(지시자)**를 추가해야 한다.  

```js
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
```
`prefix`는 접두사로 앞으로 코어태그를 사용하려면 태그시작이  `prefix`로 시작해야 한다.  

> `prefix="ctag"`라면 `<ctag:if>`형식으로 사용.  

**기능분류**|**태그**|**설명**
:-----:|:-----:|:-----
변수 지원|`set`| JSP에서 사용될 변수를 설정한다.   
-|`remove`| 설정한 변수를 제거한다.   
흐름 제어|`if`|조건에 따라 내부 코드를 수행한다.   
-|`choose`|다중 조건을 처리할 때 사용한다.   
-|`forEach`|컬렉션이나 `Map`의 각 항목을 처리할 때 사용한다.   
-|`forTokens`|구분자로 분리된 각각의 토큰을 처리할 때 사용한다.   
URL 처리|`import`|URL을 사용하여 다른 자원의 결과를 삽입한다.   
-|`redirect`|지정한 경로로 리다이렉트 한다.   
-|`url`|URL을 재작성 한다.   
기타 태그|`catch`|익셉션 처리에 사용된다.   
-|`out`|JspWriter에 내용을 알맞게 처리한 후 출력한다.   


## 흐름제어 태그

`if-else`, `switch`, `for`문 등 을 역할을 하는 코어태그로 다음과 같은 종류가 있다.  


### `<c:if>` 태그

자바의 `if` 비슷한 기능을 제공,  
단 `if-else`와 같은 기능을 할수 없다.(`else`가 없다니....)  

```html
<c:if test="조건">
...(몸체)
</c:if>
```
조건으로 다음과 같은 값이 들어갈 수 있다.  
`true`: 몸체내용 수행  
`false`: 몸체내용 수행하지 않음  
`some String`: 몸체내용 수행하지 않음  
`${expr}`: EL결과값이 `true`일경우 몸체내용 수행  
`<%= expr %>`: 표현식 결과값이 `true`인 경우 몸체내용 수행  
```js
<% 
if(elist == null) {
	...
	...(java)
%>
	...
	...(html)
<% 
}
%>
```


위의 jsp코드를 JSTL을 사용하면 아래와 같이 사용 가능.  
```html
<c:if test="${list==null}">
... (EL)
... (html)
</c:if>
```


### `<c:choose>`, `<c:when>` ,`<c:otherwise>` 태그

자바의 `switch`와 비슷한 역할을 하는 코어태그,  
3개 태그를 사용해 `if-else` 역할을 하기도 한다.  

```html
<c:choose>
	<c:when test="조건1">
		...
		...
	</c:when>
	<c:when test="조건2">
		...
		...
	</c:when>
	<c:when test="조건3">
		...
		...
	</c:when>
	
	<c:otherwise> 
		...(모든 조건에 부합하지 않을 때)
		...
	</c:otherwise>
</c:choose>
```


### `<c:forEach>` 태그

자바의 for문기능도 있으면서  
`iterator`처리와 비슷한 기능을 하는 코어태그  

```html
<c:forEach var="i" begin="1" end="10" step="2">
	번호: ${i}
</c:forEach>
```

가장 기본적 기능을 하는 `<c:forEach>`, `step`속성으로 증가분을 변경가능하다.(생략시 1씩 증가)  

`<c:forEach>`는 단순한 for문기능 뿐 아니라  
`Collection`또는 `Map`에 저장되어있는 요소를 순차적으로 꺼내사용 가능하다.(`while`문과 `iterator`와같이)  

`item`에 `collection`을, `var`에 꺼내서 사용할 **요소명**을 지정할 수 있다.  
(`list`는 `request`로 전달받은 `ArrayList`이다.)
```html
<c:forEach items="${ list }" var="dto">
	출력: ${dto.toString()}
</c:forEach>
```

list의 모든 요소를 돌고싶지 않다면 `begin`, `end`, `step`를 추가하자
```html
<c:forEach items="${ list }" var="dto" begin="1" end="3">
	출력: ${dto.toString()}
</c:forEach>
```
> 순서유지가 되지 않는 `Collection`의 경우 `begin`, `end`는 무의미하다...



## 파라미터의 저장공간

`EL`사용시 헷갈릴 만한 사항이 있다.  

`list.jsp`에선 `${param.delete}`형식으로 `delete`값을 가져오고  
`delete.jsp`에선 `${delete}`형식으로 `delete`값을 가져온다.  

```js
/* list.jsp */
var delete_st = "${param.delete}";
if(delete_st == "success")
{
  alert("Delete " + delete_st);
}
else if (delete_st == "fail") {
  alert("Delete " + delete_st);
}
...
```

```js
/* delete.jsp */
var delete_st = "${delete}"
if(delete_st == "success")
{
  alert("Delete " + delete_st);
}
else if (delete_st == "fail") {
  alert("Delete " + delete_st);
}
```


둘다 `jsp`스크립트 표현식으로 가져오려면 `<%= request.getParamter("delete") %>` 형식으로 가져온다.  

하지만 `EL`태그를 사용하면 사용방법이 달라지는데 이를 알려면 JSP 영역을 알아야한다.

## JSP영역

사실 데이터를 넘기는 방법이 여러가지 있으며 이 방법에 따라 사용하는 공간이 달라지는데 공간이 4가지가 된다.  

1. `pageScope` → 페이지Scope에 접근

2. `request Scope` → 리퀘스트Scope에 접근

3. `sessionScope` → 세션Scope에 접근

4. `applicationScope` → 어플리케이션Scope에 접근


이 4가지 공간은 각각의 영역을 갖고 있는데 다음과 같다.  

|영역|설명|사용객체
|--|--|--|
`page`영역 | 하나의 JSP페이지와 관련된 영역 | `pageContext` 객체
`request`영역 | 하나의 요청과 관련된 영역 | `request` 객체
`session`영역 | 하나의 웹 브라우저와 관련된 영역 | `response` 객체
`application`영역 | 하나의 웹 애플리케이션과 관련된 영역 | `application` 객체

각 영역은 각각의 기본객체들로 접근할 수 있다.

`page`영역이 제일 작고 `application`영역이 가장 크다. 


```java
<%
	String name = "admin";
	pageContext.setAttribute("pc_name", name);
	request.setAttribute("age", 20);
	session.setAttribute("addr", "강남구");
	application.setAttribute("tel", "010-1111-2222");
%>
이름: <%= name %> / ${ pc_name } <br>
나이: ${ age } <br>
주소: ${ addr } <br>
번호: ${ tel } <br>
```
출력값
```
웹 애플리케이션 영역 이름: admin / admin 
나이: 20 
주소: 강남구 
번호: 010-1111-2222 
```
> 그냥 `String name = "admin";`은 어느 영역에도 속해있지 않다.  

EL태그는 가장 작은 범위 영역에서 큰 범위 영역으로 찾아나가기 때문에 name으로 값을 찾을 수 있다.  


다른영역끼리 속성 name이 같을경우도 있는데 그럴경우 앞에 `scope`명을 붙이면 된다.   
`주소: ${ sessionScope.addr }`  


이제 위의 `${param.delete}`과 `${delete}`를 보면 이해가 갈듯 하다.  
`${delete}`는 `page` &rarr; `request` &rarr; `session` &rarr; `application` 영역순으로 delete라는 파라미터를 찾는다.  

반면 `${param.delete}`은 url뒤에 붙어오는 파라미터를 찾아오기 때문에 위의 4개 영역과는 관련이 없다.   
반대로 위의 4개 영역역시 url뒤에 파라미터와 관련없다.   
> `request.getAttribute()`와 `request.getParameter()` 메서드 기능이 다른것과 같다.  



또한 `request.setAttribute`로 객체를 저장하여 전송한 경우 `${dto.name}`이런식으로 사용했는데 만약 `dto`클래스에 `getName` 메서드가 정의되어 있지 않다면 오류난다.  

이는 EL의 문법중 하나로 `${dto.name}`은 사실 `${dto.getName()}`을 호출하는 것과 같다.(물론 `get`메서드 형식은 통용되는 것을 사용해야 오류 안남)

