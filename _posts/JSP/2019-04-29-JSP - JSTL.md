---
title:  "JSP/Servlet - EL, JSTL!"

read_time: false
share: false
author_profile: false
classes: wide

categories:
  - JSP

tags:
  - JSP
  - servelt

toc: true

---

## Scope (저장공간)

EL을 알아보기 전에 Scope에 대해 먼저 알아야 한다.  

WEB은 클라이언트가 요청을 하고 서버가 응답으로 이루어진다.  

서버가 요청을 MVC패턴으로 처리하다 보면 서버의 각 서블릿 객체에서 데이터를 전달하고 View역할을 하는 jsp파일에서 데이터를 출력한다.  

즉 MVC패턴으로 처리하면 서버의 여러 파일에서 클라이언트의 요청과 데이터를 이리저리 이동시킨 다는 뜻이다.  

이 데이터를 이동시키는 특별한 저장공간이 있는데 이를 Scope라 한다.  
아래 예제를 통해 알아보자.  

`list.jsp`에선 `${param.delete}`형식으로 `delete`값을 가져오고  
`delete.jsp`에선 `${delete}`형식으로 `delete`값을 가져온다.  

```js
/* list.jsp */
var delete_st = "${param.delete}";
if(delete_st == "success")
{
  alert("Delete " + delete_st);
}
else if (delete_st == "fail") {
  alert("Delete " + delete_st);
}
...
```

```js
/* delete.jsp */
var delete_st = "${delete}"
if(delete_st == "success")
{
  alert("Delete " + delete_st);
}
else if (delete_st == "fail") {
  alert("Delete " + delete_st);
}
```


`${param.delete}`을 jsp로 변환하면 `<%= request.getParamter("delete") %>`   

`${delete}`을 jsp로 변환하면 `<%= request.getAttribute("delete") %>` 이다.  

왜 이런 차이가 있는지 알려면 JSP 영역을 이해해야 한다.  

## JSP영역

사실 데이터를 넘기는 방법이 여러가지 있으며 이 방법에 따라 사용하는 공간이 달라지는데 **공간이 4가지**가 된다.  

1. `pageScope` → 페이지Scope에 접근

2. `request Scope` → 리퀘스트Scope에 접근

3. `sessionScope` → 세션Scope에 접근

4. `applicationScope` → 어플리케이션Scope에 접근

추가로 url에 붙여 파라미터 형식으로 보내는 방법이 있다.(이녀석은 저장 공간이라고 표현하기에는 부족하다....)

이 4가지 공간은 각각의 영역을 갖고 있는데 다음과 같다.  

|영역|설명|사용객체
|--|--|--|
`page`영역 | 하나의 JSP페이지와 관련된 영역 | `pageContext` 객체
`request`영역 | 하나의 요청과 관련된 영역 | `request` 객체
`session`영역 | 하나의 웹 브라우저와 관련된 영역 | `response` 객체
`application`영역 | 하나의 웹 애플리케이션과 관련된 영역 | `application` 객체

각 영역은 각각의 기본객체들로 접근할 수 있다.

`page`영역이 제일 작고 `application`영역이 가장 크다. 

EL을 사용하면 이 각 영역을 간편하게 접근하여 값을 가져올 수 있다.  
```html
<%
	String name = "admin";
	pageContext.setAttribute("pc_name", name);
	request.setAttribute("age", 20);
	session.setAttribute("addr", "강남구");
	application.setAttribute("tel", "010-1111-2222");
%>
이름: <%= name %> / ${ pc_name } <br>
나이: ${ age } <br>
주소: ${ addr } <br>
번호: ${ tel } <br>
```
출력값
```
웹 애플리케이션 영역 이름: admin / admin 
나이: 20 
주소: 강남구 
번호: 010-1111-2222 
```
> 그냥 `String name = "admin";`은 어느 영역에도 속해있지 않다.  

EL태그는 가장 작은 범위 영역에서 큰 범위 영역으로 찾아나가기 때문에 `name`으로 값을 찾을 수 있다.  


다른영역끼리 속성 `name`이 같을경우도 있는데 그럴경우 앞에 `scope`명을 붙이면 된다.   
`주소: ${ sessionScope.addr }`  


이제 위의 `${param.delete}`과 `${delete}`를 보면 이해가 갈듯 하다.  
`${delete}`는 `page` &rarr; `request` &rarr; `session` &rarr; `application` 영역순으로 delete라는 파라미터를 찾는다.  

반면 `${param.delete}`은 url뒤에 붙어오는 파라미터를 찾아오기 때문에 위의 4개 영역과는 관련이 없다.   
반대로 위의 4개 영역역시 url뒤에 파라미터와 관련없다.   
> `request.getAttribute()`와 `request.getParameter()` 메서드 기능이 다른것과 같다.  



또한 `request.setAttribute`로 객체를 저장하여 전송한 경우 `${dto.name}`이런식으로 사용했는데 만약 `dto`클래스에 `getName` 메서드가 정의되어 있지 않다면 오류난다.  

이는 EL의 문법중 하나로 `${dto.name}`은 사실 `${dto.getName()}`을 호출하는 것과 같다.(물론 `get`메서드 형식은 통용되는 것을 사용해야 오류 안남)

## EL(Expression Language)

jsp에서 자바코딩을 **좀더 간결하게** 하기 위해 사용되는 언어,  

다음과 같은 기능을 제공한다.  

* JSP 네가지 기본 객체(`request`, `response`)가 제공하는 영역의 속성 사용

* 수치연산, 관계연산, 논리연산자 제공

* 자바클래스, 메서드 호출기능 제공

* 쿠키, 기본객체의 속성 등 JSP를 위한 표현언어의 기본객체 제공

* 람다식을 이용한 함수 정의와 실행

EL은 `${ expr }`형식으로 사용한다.  
`$`달러 기호와 `{}`대괄호가 `EL`스크립트임을 표시한다.  


나중에 코어 태그와 EL을 사용해 제어문 처리를 하는데 조건문을 사용할 때 변수 타입을 알아야한다.  

EL에선 다음 5가지의 데이터 타입이 존재한다.  
**Boolean, 정수, 실수, 문자열, Null타입**  

EL을 java가 아닌 이상한 언어라 생각할 수 있는데 

EL역시 간단히 사용하기 위한 도구일 뿐이지 사실 Java문법중 하나이다.  

`Boolean`의 경우 `true`, `false`  
실수의 경우 `java.lang.Double`   
정수의 경우 `java.lang.Long`  
문자열의 경우 `java.lang.String` 타입을 가진다.  

### EL 기본객체

JSP에서 바로 접근가능한 기본객체들이 있었다.  
`request`, `response`, `session`, `application` 등...

재스퍼가 jsp를 `servlet`객체로 변환시킬 때 이런 기본객체들을 자동 생성하기에 사용할 수 있었던 것이었는데...

EL에서도 바로 접근할 수 있는 객체들이 있다.  

**EL 기본객체**|**설 명**
:-----:|:-----
`pageContext`| JSP page 자체를 나타낸다. `pageContext`를 통해 각종 기본객체를 가져올 수 있다.
`pageScope`|`pageContext` 기본 객체에 저장된 속성의 `<속성, 값>` 매핑을 저장한 `Map` 객체
`requestScope`|`request` 기본 객체에 저장된 속성의 `<속성, 값>` 매핑을 저장한 `Map` 객체
`sessionScope`|`session` 기본 객체에 저장된 속성의 `<속성, 값>` 매핑을 저장한 `Map` 객체
`applicationScope`|`application` 기본 객체에 저장된 속성의 `<속성, 값>` 매핑을 저장한 `Map` 객체
`param`|요청 파라미터의 `<파라미터이름, 값>` 매핑을 저장한 `Map` 객체. 파라미터 **값의 타입은 `String`으로서,** `request.getParameter(이름)`의 결과와 동일하다.
`paramValues`|요청 파라미터의 `<파라미터이름, 값배열>` 매핑을 저장한 `Map` 객체. **값의 타입은 `String[]`으로서,** `request.getParameterValues(이름)`의 결과와 동일하다.
`header`|요청 정보의 `<헤더이름, 값>` 매핑을 저장한 `Map` 객체, `request.getHeader(이름)`의 결과와 동일하다.
`headerValues`|요청 정보의 `<헤더이름, 값 배열>` 매핑을 저장한 `Map` 객체. `request.getHeaders(이름)`의 결과와 동일하다.
`cookie`|`<쿠키 이름, Cookie>` 지정한 `Map` 객체. `request.getCookies()`로 구한 Cookie배열로부터 매핑을 생성한다.
`initParam`|초기화 파라미터의 `<이름, 값>` 매핑을 저장한 `Map` 객체, `application.getInitParameter(이름)`의 결과와 동일하다.

이중 위에서 소개했던 4가지 역역 `pageScope`, `requestScope`, `sessionScope`, `applicationScope`은 굳이 명시하지 않아도 가장 작은 범위인 `pageScope`부터 돌며 안의 속성을 접근할 수 있다.  

모든 기본객체의 형식이 `Map`객체이며 `key`값을 통해 `value`값을 얻어올 수 있다.  

`${ pageScope.key }`이런식으로.... `pageScope`는 생략가능함으로 `${ key }` 키값을 통해 바로 `value`를 가져올 수 있다.  

`pageContext`객체는 jsp에서 제공하는 기본객체로 다른 jsp와 1:1 매칭되는 객체로 다른 기본객체를 함수를 통해 반환할 수 있다.  


`EL`에서 접근할 수 있는 JSP의 기본객체는 `pageContext`뿐이다.  
만약 request와 session과 같은 기본객체에 접근하고 싶다면 `pageContext`를 통해 얻어올 수 있다.  

`request`를 통해 `url`을 가져오는 `request.getRequestURI()`메서드를 EL을 통해 사용하고 싶다면 

`url: ${ pageContext.request.requestURI }` 이런식으로 사용가능하다.  
`EL`문법에 따라 `requestURI`이 `getRequestURI()`메서드를 호출하는 것 과 같다.  

`application`이나 `session`같은 기본객체를 얻어와 메서드 호출도 가능하다.

> `pageContext` : https://kouzie.github.io/jsp/JSP-버퍼,-application,-exception,-웹-기본구조,-모듈화/#기본객체---pagecontext


또한 `request.getHeader()`메서드를 통해 `header`정보를 읽어왔었는데 EL 태그는 `header`라는 EL기본객체가 제공되기 때문에 바로 접근 가능하다.  

```js
name: ${ param.name }<br>
url: ${ pageContext.request.requestURI }<br>
referor: ${ header.referer }
```

위와 같은 EL태그는 재스퍼에 의해 java코딩으로 다음과 같이 변경된다.  
```java
out.write("\tname: ");
out.write((java.lang.String) org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate("${ param.name }", java.lang.String.class, (javax.servlet.jsp.PageContext)_jspx_page_context, null));
out.write("<br>\r\n");
out.write("\turl: ");
out.write((java.lang.String) org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate("${ pageContext.request.requestURI }", java.lang.String.class, (javax.servlet.jsp.PageContext)_jspx_page_context, null));
out.write("<br>\r\n");
out.write("\treferor: ");
out.write((java.lang.String) org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate("${ header.referer }", java.lang.String.class, (javax.servlet.jsp.PageContext)_jspx_page_context, null));
out.write("\r\n");
```


### EL 산술 연산자

```html
${ 3 + 5 }
${ 3 * 5 }
${ 3 / 5 }
${ 3 div 5 }
${ 3 % 5 }
${ 3 mod 5 }
${ 10/8 }
${ null + null }
${ null + 1 }
```

출력값
```
8
15
0.6
0.6
3
3
1.25
0
1
```

정수 실수 상관없이 사칙연산을 모두 수행한다.  

결과값도 마찬가지.  

참고로 `${ 0 / 10 }` 0을 나누는 연산 또한 예외처리 되었는지 오류를 내보내지 않고 0.0을 출력한다. 

### EL empty 연산자

```
${ empty null } <
${ empty "" }
${ empty 0 }
```
출력값
```
true
true
false
```

아래와 같이 컬렉션 객체에 empty 연산자를 사용하는 경우  
`${ empty list }`  

`list`가 비어있어도 `true`반환한다.  

### EL 세미콜론 연산자와 할당연산자

세미콜론 연산자는 EL을 사용하여 출력할 때 `;` 을 사용해 여러값을 `{}`대괄호 안에 넣어 마지막 값만 출력한다.  

`${ 10; 20; 30; 40 }`  
출력값: `40`

마지막값만 출려하기 위한 연산자로 쓸모 없어 보이지만 할당연산자와 사용하면 유용하다.  

EL에서 연산 혹은 출력을 위한 변수를 만들고 싶다면 할당연산자를 사용하지 않고는 다음과 같이 `request`객체에 담아서 사용해야한다.  

```js
<%
	int age = 20;
	request.setAttribute("age", age);
%>
${ age }
```

이런식으로 사용했는데 할당 연산자를 사용하면 `request`에 담을 필요 없이 바로 선언, 초기화 가능하다.  

```js
${ age = 20 }<br> 
${ age }<br> 
```

단 이렇게 사용하면 20이 2번 출력된다....

이때 세미콜론 연산자와 같이 사용하면 간편하다.  

```js
${ age = 20; "" }
${ age }<br> 

${ name = "hong"; "" }
${ name }<br>

${ m=[1, 2, 3]; "" }
${ m[0] }<br>
```
출력값
```
20
hong
1
```
초기화시 뒤에 세미콜론과 함께 빈 문자열을 붙여 출력시키지 않는다.  

### EL - 객체의 메서드 호출하기

`EL2.2`버전부터 추가된 기능으로 생성된 객체의 메서드를 직접 호출 가능하다.  

먼저 `java Resources`폴더에 다음 클래스를 정의
```java
package days13;

public class Fruit {
	String fruit;
	
	public void setFruit(String fruit) {
		this.fruit = fruit;
	}
	
	public String getFruitName() {
		return "과일 이름은 " + fruit + "입니다.";
	}
}
```

위 클레스로 객체를 생성하고 EL을 사용해 `getFruitName()`메서드를 호출하자.  
```java
<%
	Fruit fruit = new Fruit();
	fruit.setFruit("사과");
	request.setAttribute("f", fruit);
%>
${ f.setFruit("배") }
${ f.getFruitName() }
```

출력값
```
과일 이름은 배입니다.
```

> 참고: jsp 2.1 이하버전에선 컴파일 에러난다.  


### EL - 정적 메서드 호출하기

정적메서드를 호출하는 방법은 2가지 있다.  

1. `jsp2.1` 이전 버전 호출방법  
2. `jsp2.2` 이후 버전 호출방법  

물론 `jsp2.2`버전에서 `jsp2.1`버전의 사용방법으로 정적메서르들 호출해도 된다.  

`jsp2.1` 이전 버전으로는 TLD(Tag Library Description)을 사용해서 정적메서드와 매칭된 파일을 별도로 작성후 `web.xml`에 등록해야한다.  

먼저 간단한 정적메서드를 정의하자.  

```java
public class FormatUtil {
	public static String number(long number, String pattern) {
		DecimalFormat format = new DecimalFormat(pattern);
		return format.format(number);
	}
}
```
`DecimalFormat`을 사용해 원하는 포멧으로 정수를 문자열로 출력하는 `static`메서드이다.  


`number()`메서드를 태그처럼 사용할 수 있도록 `TLD`파일을 작성하도록 하자.  

확장자는 `.tld`이고 파일명은 `el-functions.tld`이다.  

이 tld파일은 `/WEB-INF/tlds/`, `/WEB-INF/jsp/` 폴더에 위치시켜야 한다.(안그러면 오류남)


```xml
<?xml version="1.0" encoding="UTF-8" ?>
<taglib 
	xmlns="http://java.sun.com/xml/ns/javaee" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
		http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd"
	version="2.1">
 
    <description>EL에서 함수실행</description>
    <tlib-version>1.0</tlib-version>
    <short-name>ELfunctions</short-name>
 
    <function>
        <description>숫자 포멧팅</description>
        <name>formatNumber</name>
        <function-class>com.util.FormatUtil</function-class>
        <function-signature>
        	java.lang.String number(long, java.lang.String)
        </function-signature>
    </function>
</taglib>
```
xml형식으로 작성되며 `<function>`태그를 통해 클래스와 메서드를 태그로 쓸 수 있도록 설정한다.  

정적메서드를 사용하고 싶은 jsp페이지에 다음과 같은 
`tablib` 디렉티브를 선언하면 된다.  

`<%@ taglib prefix="elfunc" uri="/WEB-INF/tlds/el-functions.tld" %>`


그리고 지시자에서 정의한 접두사 `elfunc` 와 함께 사용하면 된다.  
```html
${ price = 12345; "" }
베추 가격은 ${ elfunc:formatNumber(price, "#,##0") } 입니다.
```


사실 `jsp2.2` 이후 버전에선 위처럼 복잡하게 정적메서드를 호출하지 않는다.  

그냥 객체의 메서드 호출하듯이 사용하면 된다.  

page 디렉티브로 `FormatUtil`클래스를 import하고  

`<%@page import="com.util.FormatUtil"%>`

객체 메서드 호출하듯이 사용하면 된다.
```html
${ price = 12345; "" }
베추 가격은 ${ FormatUtil.number(price, "#,##0") } 입니다.
```
출력값
```
베추 가격은 12,345 입니다.
```

### EL 비활성화  

EL을 사용하고 싶지 않다면, 물론 그럴일은 없겠지만 사용하고 싶지않다면 기능을 끌 수 있다.  

`${ }`는 더이상 EL 문법이 아닌 문자열로 취급된다.  

비활성화 하는 방법은 `web.xml`의 `<jsp-config>`태그안에서 설정하는 것 과  
`page` 디렉티브에서 `isELIgnored`설정을 `true`로 세팅하는 방법이 있다.  

web.xml에서 설정하는 것은 다음과 같다.  
```xml
<!-- web.xml -->
<jsp-config>
	...
	...
	<jsp-property-group>
		<url-pattern>/TestELIgnore/*</url-pattern>
		<el-ignored>true</el-ignored>
	</jsp-property-group>
</jsp-config>
```
`<jsp-confi>`  
`<jsp-property-grou>`  
`<url-pattern>`  
`<el-ignored>`  
4개 태그를 통해 url-mapping에 해당하는 모든 파일에 EL문법을 무효화 한다.  

2번째 방법인 page디렉티브를 사용하는 방법은 다음과 같다.  

`<%@ page isELIgnored="true" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>`

`isELIgnored="true"`를 통해 해당 jsp 페이지에선 더이상 EL을 사용하지 못하도록 설정한다.  



## JSTL

스트립트릿, 표현부를 `if`문, `while`문등 조건문과 같이 사용하면 코드가 지저분하고 유지보수하기 힘들어 진다.  

이를 해결하기 위해 `JSTL`(표준 태그 라이브러리)을 사용한다.  
직관적이고 간결한 코드를 제공한다.  

EL과 JSTL을 같이 사용하면 jsp의 스크립트릿으로 코딩하는 것 보다 길이가 훨씬 짧아진다.  

JSTL을 사용하기 위해 라이브러리를 받아야 하는데 아래 주소에서 다운 가능하다.

>https://search.maven.org/artifact/jstl/jstl/1.2/jar  

다운받아 jdbc드라이버와 같이 `WEB-INF/lib/`위치에 저장하면 된다.  

### 태그의 종류

**라이브러리**|**하위 기능**|**접두어**|**관련 URI**
:-----:|:-----:|:-----:|:-----:
코어| 변수 지원<br>흐름 제어<br>URL 처리| c| http://java.sun.com/jsp/jstl/core
XML| XML 코어<br>흐름제어<br>XML 변환| x| http://java.sun.com/jsp/jstl/xml 
국제화| 지역<br>메세지 형식<br>숫자 및 날짜 형식| fmt| http://java.sun.com/jsp/jstl/fmt
데이터베이스| SQL| sql| http://java.sun.com/jsp/jstl/sql
함수| 콜렉션 처리<br>String 처리|fn | http://java.sun.com/jsp/jstl/functions


JSTL에서 제공하는 태그의 종류는 **코어, XML, 국제화, 데이터베이스, 함수** 등의 태그가 있지만  

**변수지원, 흐름제어, URL처리** 역할을 하는 **코어태그**에 대해 먼저 알아보자.  

### 코어태그

코어태그 라이브러리를 사용하려면 `html`태그 위에 다음과 같은 **`taglib`디렉티브(지시자)**를 추가해야 한다.  

```js
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
```

`prefix`는 접두사로 앞으로 코어태그를 사용하려면 태그시작이  `prefix`로 시작해야 한다.  

> `prefix="ctag"`라면 `<ctag:if>`형식으로 사용.  


코어 태그에서 지원하는 기능별 사용하는 태그는 아래와 같다.  

**기능분류**|**태그**|**설명**
:-----:|:-----:|:-----
변수 지원|`set`| JSP에서 사용될 변수를 설정한다.   
-|`remove`| 설정한 변수를 제거한다.   
흐름 제어|`if`|조건에 따라 내부 코드를 수행한다.   
-|`choose`|다중 조건을 처리할 때 사용한다.   
-|`forEach`|컬렉션이나 `Map`의 각 항목을 처리할 때 사용한다.   
-|`forTokens`|구분자로 분리된 각각의 토큰을 처리할 때 사용한다.   
URL 처리|`import`|URL을 사용하여 다른 자원의 결과를 삽입한다.   
-|`redirect`|지정한 경로로 리다이렉트 한다.   
-|`url`|URL을 재작성 한다.   
기타 태그|`catch`|익셉션 처리에 사용된다.   
-|`out`|JspWriter에 내용을 알맞게 처리한 후 출력한다.   


## 흐름제어 태그

`if-else`, `switch`, `for`문 등 을 역할을 하는 코어태그로 다음과 같은 종류가 있다.  


### `<c:if>` 태그

자바의 `if` 비슷한 기능을 제공,  
단 `if-else`와 같은 기능을 할수 없다.(`else`가 없다니....)  

```html
<c:if test="조건">
...(몸체)
</c:if>
```
조건으로 다음과 같은 값이 들어갈 수 있다.  
`true`: 몸체내용 수행  
`false`: 몸체내용 수행하지 않음  
`some String`: 몸체내용 수행하지 않음  
`${expr}`: EL결과값이 `true`일경우 몸체내용 수행  
`<%= expr %>`: 표현식 결과값이 `true`인 경우 몸체내용 수행  
```js
<% 
if(elist == null) {
	...
	...(java)
%>
	...
	...(html)
<% 
}
%>
```


위의 jsp코드를 JSTL을 사용하면 아래와 같이 사용 가능.  
```html
<c:if test="${list==null}">
... (EL)
... (html)
</c:if>
```

> `==`과 `!=`같은 연산자는 다음으로 치환 가능하다.  
`<c:if test="${list eq null}">`  
`<c:if test="${list ne null}">`  
`equal`과 `not equal`의 약자.  


### `<c:choose>`, `<c:when>` ,`<c:otherwise>` 태그

자바의 `switch`와 비슷한 역할을 하는 코어태그,  
3개 태그를 사용해 `if-else` 역할을 하기도 한다.  

```html
<c:choose>
	<c:when test="조건1">
		...
		...
	</c:when>
	<c:when test="조건2">
		...
		...
	</c:when>
	<c:when test="조건3">
		...
		...
	</c:when>
	
	<c:otherwise> 
		...(모든 조건에 부합하지 않을 때)
		...
	</c:otherwise>
</c:choose>
```


### `<c:forEach>` 태그

자바의 for문기능도 있으면서  
`iterator`처리와 비슷한 기능을 하는 코어태그  

```html
<c:forEach var="i" begin="1" end="10" step="2">
	번호: ${i}
</c:forEach>
```

가장 기본적 기능을 하는 `<c:forEach>`, `step`속성으로 증가분을 변경가능하다.(생략시 1씩 증가)  

`<c:forEach>`는 단순한 for문기능 뿐 아니라  
`Collection`또는 `Map`에 저장되어있는 요소를 순차적으로 꺼내사용 가능하다.(`while`문과 `iterator`와같이)  

`item`에 `collection`을, `var`에 꺼내서 사용할 **요소명**을 지정할 수 있다.  
(`list`는 `request`로 전달받은 `ArrayList`이다.)
```html
<c:forEach items="${ list }" var="dto">
	출력: ${dto.toString()}
</c:forEach>
```

list의 모든 요소를 돌고싶지 않다면 `begin`, `end`, `step`를 추가하자
```html
<c:forEach items="${ list }" var="dto" begin="1" end="3">
	출력: ${dto.toString()}
</c:forEach>
```
> 순서유지가 되지 않는 `Collection`의 경우 `begin`, `end`는 무의미하다...


> 참고사이트: https://www.tutorialspoint.com/jsp/jsp_standard_tag_library.htm