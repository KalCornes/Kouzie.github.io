---
title:  "JSP/Servlet - 게시판!"

read_time: false
share: false
author_profile: false
classes: wide

categories:
  - JSP

tags:
  - JSP
  - servelt

toc: true

---

## 게시판 구축하기

지금까지 인증처리, 간단한 게시판 구축 등을 했는데 이번엔 진짜 회원가입부터 로그인까지 가능한 하나의 완전한 웹 어플리케이션을 만들어보자.  

프로젝트명은 jspPro, board라는 폴더와 패키지 안에 게시판 관련된 파일들을 생성하자.  

우선 회원가입 기능만 구현하도록 해보자.  

### DB연결 객체 

DB연결과정은 기존에 있던것을 사용하자.  

`/WEB-INF/lib` 폴더에 `ojdbc6.jar`파일을 넣고 톰캣(WAS)서버가 제공하는 커넥션 풀 객체를 사용하자  
```java
public class ConnectionProvider {
	public static Connection getConncection() throws NamingException, SQLException
	{
		Context initContext = new InitialContext();
		Context envContext  = (Context)initContext.lookup("java:/comp/env");
		DataSource ds = (DataSource)envContext.lookup("jdbc/myoracle");
		Connection conn = ds.getConnection();
		return conn;
	}
}
```
> https://kouzie.github.io/jsp/JSP-DBCP,-세션/

그리고 DB연결객체를 close, rollback할수 있도록 도와주는 `JdbcUtil`클래스 정의
```java
public class JdbcUtil {
	public static void close(ResultSet rs) {
		if (rs != null) {
			try { rs.close(); }
			catch (SQLException ex) { }
		}
	}
	
	public static void close(Statement stmt) {
		if (stmt != null) {
			try { stmt.close(); }
			catch (SQLException ex) { }
		}
	}
	
	public static void close(Connection conn) {
		if (conn != null) {
			try { conn.close(); }
			catch (SQLException ex) { }
		}
	}

	public static void rollback(Connection conn) {
		if (conn != null) {
			try { conn.rollback(); }
			catch (SQLException ex) { }
		}
	}
}
```

먼저 회원가입을 위한 회원테이블을 생성하자.  

```sql
CREATE TABLE member21 (
    memberid VARCHAR(50) PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    password VARCHAR(50) NOT NULL,
    regdate DATE DEFAULT SYSDATE
);
```

### Member - Member21에서 사용자 데이터저장용 DTO 객체

테이블에서 가져온 데이터를 저장, 관리용 DTO객체를 정의하자.  

`Meber21`테이블 속성에 해당하는 필드를 정의하고 getter, setter 메서드를 자동 생성.

추가적으로 회원가입시 패스워드와 확인용 패스워드가 일치하는지 검사하는 `matchPassword`메서드를 정의한다.    

```java
public class Member {
private String memberid;
private String name;
private String password;
private Date regdate;
public Member(String memberid, String name, String password, Date regdate) {
	this.memberid = memberid;
	this.name = name;
	this.password = password;
	this.regdate = regdate;
}
public String getMemberid() {
	return memberid;
}
public void setMemberid(String memberid) {
	this.memberid = memberid;
}
...
...
public boolean matchPassword(String pwd) {
	return password.equals(pwd);
}
```

### MemberDao - 멤버 객체 삽입, 검색 클래스

실제 `Membe21` 테이블에 멤버를 추가하고 기존에 멤버가 있는지 검색하는 `MemberDAO` 객체를 정의한다.  
```java
public class MemberDao {

	public Member selectById(Connection conn, String memberid) {
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		try {
			pstmt = conn.prepareStatement("SELECT * FROM member21 WHERE memberid = ?");
			pstmt.setString(1, memberid);
			rs = pstmt.executeQuery();
			Member member = null;
			if (rs.next()) {
				member = new Member(
						rs.getString("memberid"),
						rs.getString("name"),
						rs.getString("password"),
						rs.getDate("regdate")
						);
				return member;
			}
		} catch (Exception e) {
			System.out.println(e);
		} finally {
			JdbcUtil.close(rs);
			JdbcUtil.close(pstmt);
		}
	}
	
	private Date toDate(Timestamp date){
		return date == null ? null : new Date(date.getTime());
	}
	public void insert(Connection conn, Member mem)	throws SQLException {
		try (PreparedStatement pstmt 
				= conn.prepareStatement("INSERT INTO (memberid, name, password) member21 value(?,?,?)");)
		{
			pstmt.setString(1, mem.getMemberid());
			pstmt.setString(2, mem.getName());
			pstmt.setString(3, mem.getPassword());
			
			pstmt.executeQuery();
		} catch (Exception e) {
			System.out.println(e);
		}
	}
}
```

회원가입을 위한 DTO, DAO객체를 만들었으니 이벤트 처리용 객체들을 만들어보자.  

### 컨트롤러 정의

`*.do`확장자를 요청하는 모든 url은 컨트롤러의 제어를 받아 요청, 응답되어진다.  

저번 url기반 컨트롤러 정의했던 것 과 전혀 달라진 것 이 없다.  
> https://kouzie.github.io/jsp/JSP-MVC패턴/#요청-uri명령-기반-컨트롤러


```xml
<servlet>
	<servlet-name>ControllerUsingURI</servlet-name>
	<servlet-class>board21.mvc.controller.ControllerUsingURI</servlet-class>
	<init-param>
		<param-name>configFile</param-name>
		<param-value>/WEB-INF/view/board21/commandHandler.properties</param-value>
	</init-param>
	<load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
	<servlet-name>ControllerUsingURI</servlet-name>
	<url-pattern>*.do</url-pattern>
</servlet-mapping>
```


```java
public class ControllerUsingURI extends HttpServlet{
	private Map<String, CommandHandler> commandHandlerMap = new HashMap<>();
	
	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		process(request, response);
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		process(request, response);
	}

	@Override
	public void init() throws ServletException {
		String configFile = getInitParameter("configFile");
		Properties prop = new Properties();
		String configFilePrath = getServletContext().getRealPath(configFile);
		System.out.println(configFile);
		try(FileInputStream fis = new FileInputStream(configFilePrath))
		{
			prop.load(fis);
		} catch (IOException e) {
			throw new ServletException(e);
		}
		Iterator<Object> keyiter = prop.keySet().iterator();
		while (keyiter.hasNext()) {
			String command = (String) keyiter.next();
			String handlerClassName = prop.getProperty(command);
			try {
				Class<?> handlerClass = Class.forName(handlerClassName);
				CommandHandler handlerInstance = (CommandHandler) handlerClass.newInstance();
				commandHandlerMap.put(command, handlerInstance);
			}
			catch (ClassNotFoundException | InstantiationException | IllegalAccessException  e) {
				throw new ServletException(e);
			}
		}
	}

	private void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		String command = request.getRequestURI();
		if (command.indexOf(request.getContextPath()) == 0) {
			command = command.substring(request.getContextPath().length());
		}
		System.out.println(command);
		CommandHandler handler = commandHandlerMap.get(command);
		if (handler == null) {
			handler = new NullHandler(); //404에러를 응답하는 핸들러 클래스
		}
		String viewPage = null;
		try {
			viewPage = handler.process(request, response);
		}
		catch (Exception e) {
			throw new ServletException(e);
		}
		if(viewPage != null) {
			String prefix = "/WEB-INF/view/board21";
			viewPage = prefix + viewPage;
			RequestDispatcher dispatcher = request.getRequestDispatcher(viewPage);
			System.out.println(viewPage);
			dispatcher.forward(request, response);
		}
	}
}
```

서버 시작시 `commandHandler.properties`파일을 열어 url명령과 처리할 서블릿 객체를 `Map`객체를 통해 목록화 시켜 가지고 있고  
명령이 들어올 때 마다 `Map`에서 알맞은 서블릿 객체를 꺼내 `process(request, response)`메더스들 호출한다.    

그리고 서블릿 객체가 반환한 View페이지로 포워딩 시키면 끝!  


### 이벤트 처리 서블릿  

`commandHandler.properties`설정 파일에 따라 이벤트가 처리되는데 **회원가입의 경우 `join.do`라는 url**을 서버에 요청한다.  

위의 컨트롤러가 관리하는 이벤트 처리목록용 `Map`객체 안의 요소가 `CommandHandler`이다. 

`private Map<String, CommandHandler> commandHandlerMap = new HashMap<>();`

`CommandHandler`는 모든 이벤트 처리용 서블릿 객체(Model)이 상속하는 인터페이스로 다형성을 활용하여 하나의 `Map`객체로 다양한 이벤트 처리 클래스를 관리할 수 있다.  


```java
public interface CommandHandler {
	public String process(HttpServletRequest request, HttpServletResponse response) throws Exception;
}
```

아무런 `*.do` url패턴이지만 등록하지 않은 이벤트가 요청 될 수 있다.  

위의 컨트롤러에서도 `Map`에서찾는 이벤트 객체가 없어 `null`을 반환했을 때 예외처리를 하였는데  

`NullHandler`로 이벤트를 처리하는 것이다.  
```java
CommandHandler handler = commandHandlerMap.get(command);
if (handler == null) {
	handler = new NullHandler(); //404에러를 응답하는 핸들러 클래스
}
```

등록되지 않는 이벤트를 처리하는 Modal 객체인 `NullHandler`를 아래와 같이 정의하자.  

```java
public class NullHandler implements CommandHandler {
	@Override
	public String process(HttpServletRequest request, HttpServletResponse response) throws Exception {
		response.sendError(HttpServletResponse.SC_NOT_FOUND);
		return null;
	}
}
```
그냥 404에러를 `response`객체에 저장.  


### JoinHandler - 회원가입 이벤트처리

이벤트 처리 클래스를 등록하기 위해 `commandHandler.properties`에 아래처럼 추가하자.  
`/join.do=board21.mvc.commmand.JoinHandler`

이제 컨트롤러는 `join.do`라는 url패턴으로 요청이 들어오면 `JoinHandler`객체의 `process()`메서드를 호출하게 될 것이다.  

아래 회원가입 링크를 누르면  

`<a href="<%= request.getContextPath() %>/join.do">회원가입</a>`

`a`태그를 눌러 요청하는 것은 당연히 `get`방식으로 요청이 서버로 전송될 것이고 서버는 회원가입 페이지로 포워딩 시킨다.   

회원가입 데이터를 입력하고 `submit` 버튼을 누르면 post방식으로 요청이 서버로 전송될 것이고 서버는 회원가입 결과페이지로 포워딩 시킨다.  

모든것이 포워딩 작업으로 이루어지기 때문에 같은 `join.do` url로 `get`, `post`요청을 한다.  

`JoinHandler`는 `get`방식요청일 경우 `joinForm.jsp`페이지 url을 반환하고  
`post`방식요청일 경우 `joinSuccess.jsp`페이지 url을 반환한다.  


먼저 `joinForm.jsp`을 만들어보자.  

```html
<!-- joinForm.jsp -->
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta charset="UTF-8">
<title>회원가입</title>
</head>
<body>
<h3>JoinForm.jsp</h3>
<form action="join.do" method="post">
	<p>
		아이디: <input type="text" name="memberid" value="${ param.id }" />
		<c:if test="${ errors.memberid }">
			ID를 입력하세요
		</c:if>
		<c:if test="${ errors.duplicateId }">
			이미 사용중인 ID입니다.
		</c:if>
	</p>
	<p>
		이름: <input type="text" name="name" value="${ param.name }"/>
		<c:if test="${ errors.name }">
			이름을 입력하세요
		</c:if>
	</p>
	<p>
		암호: <input type="password" name="password" value="${ param.password }"/>
		<c:if test="${ errors.password }">
			암호를 입력하세요
		</c:if>
	</p>
	<p>
		확인: <input type="password" name="comfirmPassword" value="${ param.comfirmPassword }" />
		<c:if test="${ errors.confirmPassword }">
			확인을 입력하세요
		</c:if>
		<c:if test="${ errors.notMatch }">
			암호와 확인이 일치하지 않습니다.
		</c:if>
	</p>
	<input type="submit" value="가입" />
</form>
</body>
</html>
```
중간중간에 `errors`객체의 각종 속성을 검사하여 `true`일 경우 오류문구를 출력한다.  

먼저 이 error객체에 설명하고 가면 `Map<String, Boolean> errors = new HashMap<>();` 인런식으로 정의되어 있다.  
`key`로 문자열 `notMatch`를, `value`로 `boolean`값을 두어 각종 오류가 발생했는지 발생하지 않았는지 `errors`라는 `Map`객체 하나로 확인할 수 있다.

> 오늘 알게된 사실: 코어태그로 Map객체의 name에 해당하는 value도 가져올 수 있다.  

![image34]({{ "/assets/jsp/image34.png" | absolute_url }}){: .shadow}     

그럼 이제 가입결과 페이지 `joinSuccess.jsp`를 만들자.

```html
<!-- joinSuccess.jsp -->
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>회원가입 - 결과</title>
</head>
<body>
	<h3>joinSuccess.jsp</h3>
	${ param.name }님, 가입을 환영합니다.<br>
</body>
</html>
```
사실 회원가입 실패의 경우 `errors`객체를 가지고 `joinForm.jsp`로 포워딩 시킬 것이기 때문에 성공할 경우에만 `joinSuccess.jsp`로 이동시킨다.  

즉 `JoinHandler` Model객체는 `get`방식일때, 혹은 에러가 발생했을 경우 `joinForm.jsp`문자열을 반환하고   
`post`방식일 때 `joinSuccess.jsp` 문자열을 반환한다.  

```java
public class JoinHandler implements CommandHandler{

	private static final String FORM_VIEW = "/joinForm.jsp";
	
	private JoinService joinService = new JoinService();
	
	@Override
	public String process(HttpServletRequest request, HttpServletResponse response) throws Exception {
		if (request.getMethod().equalsIgnoreCase("GET")) {
			return processForm(request, response);
		}
		else if (request.getMethod().equalsIgnoreCase("POST")) {
			return processSubmit(request, response);
		}
		else {
			response.setStatus(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
			return null;
		}
	}

	private String processForm(HttpServletRequest request, HttpServletResponse response) {
		return FORM_VIEW;
	}
	private String processSubmit(HttpServletRequest request, HttpServletResponse response) {
		JoinRequest joinReq = new JoinRequest();
		//받은 요청을 유효한 값인지 확인하는 JoinRequest 객체
		joinReq.setMemberid(request.getParameter("memberid"));
		joinReq.setName(request.getParameter("name"));
		joinReq.setPassword(request.getParameter("password"));
		joinReq.setConfirmPassword(request.getParameter("comfirmPassword"));
		Map<String, Boolean> errors = new HashMap<>();
		request.setAttribute("errors", errors);
		joinReq.validate(errors);

		if (!errors.isEmpty()) {
			//errors안에 값이 있다면
			return FORM_VIEW;
		}
		try {
			joinService.join(joinReq);
			//INSERT작업 수행
			return "/joinSuccess.jsp";
		} catch (DuplicationException e) {
			errors.put("duplicateId", Boolean.TRUE);
			return FORM_VIEW;
		}
	}
}
```
살펴보아야 할것은 `post`방식에서 호출되는 `processSubmit()`메서드  

`JoinRequest`객체는 사용자가 `joinForm.jsp`에서 입력할 값들이 유효한지 확인하는 객체이다.  
`validate()`메서드를 통해 `errors`객체에 유효한지 결과를 추가한다.  

```java
public class JoinRequest {
	private String memberid;
	private String name;
	private String password;
	private String confirmPassword;
	
	public boolean isPasswordEqualToConfirm()
	{
		return password != null && password.equals(confirmPassword);
	}
	public void validate(Map<String, Boolean> errors) {
		checkEmpty(errors, memberid, "memberid");
		checkEmpty(errors, name, "memberid");
		checkEmpty(errors, password, "memberid");
		checkEmpty(errors, confirmPassword, "confirmPassword");
		//비어있거나 null값이면 FALSE, 
		//comfirmPassWord가 TRUE, 서로 일치한다면 notMatch에 TRUE 
		if (!errors.containsKey("confirmPassword")) {
			if(!isPasswordEqualToConfirm()) {
				errors.put("notMatch", Boolean.TRUE);
			}
		}
	}
	
	private void checkEmpty(Map<String, Boolean> errors, String value, String fieldName) {
		if (value == null || value.isEmpty()) {
			errors.put(fieldName, Boolean.TRUE);
		}
	}
	public String getMemberid() {
		return memberid;
	}
	public void setMemberid(String memberid) {
		this.memberid = memberid;
	}
	...
	...
}
```
`JoinRequest`는 `Member` DTO객체와 유사한데 회원가입을 위한 DTO라고 볼수 있다.  

회원데이터는 회원가입 뿐 아니라 다방면에서 쓰여야 하는데 회원가입 때문에 여러 메서드를 `Member` DTO객체에 주렁주렁 달고 있을 필요는 없기 때문에 `JoinRequest`를 별도로 생성한것.  

그리고 `JoinRequest`객체에서 ID를 `SELECT`해와서 ID중복체크를 하지 않는데 중복체크는 `joinService.join()` 메서드에서 발생한다.  

다시 `JoinHandler`의 `processSubmit()`메서드를 살펴보면 `joinService.join()`메서드에서 중복예외객체인 `DuplicationException`를 throw한다.  
```java
/* JoinHandler */
...
try {
	joinService.join(joinReq);
	//INSERT작업 수행
	return "/joinSuccess.jsp";
} catch (DuplicationException e) {
	errors.put("duplicateId", Boolean.TRUE);
	return FORM_VIEW;
}
...
```

실제 `JoinService`가 `MemberDAO` 사용해 `INSERT` 쿼리를 수행하기 전 `SELECT`쿼리를 수행해 중복체크를 하는데  
만약 클라이언트가 넘긴 ID값이 DB에 이미 존재한다면 직접 정의한 예외 `DuplicationException`객체가 `throw`된다.
```java
public class DuplicationException extends RuntimeException{
}
```
그냥 구분하기 위해 만들어둔 깡통 예외객체...

즉 `JoinService` `INSERT`하기 전 `memberDao.selectById()`메서드를 통해 이미 ID가 존재하는지 체크하고 `DuplicationException`예외를 `throw`할지 말지 결정한다.  

ID가 존재하지 않을경우 `memberDao.insert()`메서드로 입력받은 `JoinRequest`객체로 `Member` DTO객체를 생성하여 `INSERT`하고 끝
```java
public class JoinService {
	private MemberDao memberDao = new MemberDao();
	public void join(JoinRequest joinReq)
	{
		Connection conn = null;
		try {
			conn = ConnectionProvider.getConncection();
			conn.setAutoCommit(false);
			//자동 커밋 X
			Member member = memberDao.selectById(conn, joinReq.getMemberid());
			if (member != null) {
				// 이미 MemberId값이 존재한다면
				JdbcUtil.rollback(conn);
				throw new DuplicationException();
			}
			memberDao.insert(conn, new Member(
					joinReq.getMemberid(),
					joinReq.getName(),
					joinReq.getPassword(),
					new Date()
					));
			conn.commit();
		} catch (SQLException | NamingException e) {
			System.out.println("joinSerivce");
			JdbcUtil.rollback(conn);
			throw new RuntimeException(e);
		} finally {
			JdbcUtil.close(conn);
		}
	}
}
```

### 회원가입 요약

`commandHandler.properties`에 `JoinHandler` 등록

get방식일 때 `joinForm.jsp`반환, post방식일 때 `processSubmit()`메서드 호출

`processSubmit()`에서 `errors`객체로 유효값 확인 및 SQL쿼리 수행  

`joinServiec`에서 `SELECT`쿼리 수행 후 ID가 이미 존재한다면 `DuplicationException`예외 발생

ID중복 없을경우 `INSERT`쿼리 수행

`INSERT`쿼리까지 수행되면 `JoinHandler`는 `joinSuccess.jsp` 반환.