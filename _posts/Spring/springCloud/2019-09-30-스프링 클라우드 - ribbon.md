---
title:  "spring cloud - ribbon!"

read_time: false
share: false
author_profile: false
classes: wide

categories:
  - spring

tags:
  - eureka
  - spring-cloud

toc: true

---

## ribbon

기존에 `eureka-zuul`을 사용해 로드밸런싱을 지원했었다.  

> https://kouzie.github.io/spring/스프링-클라우드-eureka-zuul  

이는 `zuul`에 기본적으로 `ribbon`이 포함되었기 때문에 가능한 작업이다.  

이번엔 별도의 gateway를 사용하지 않고 유레카 `Service Discovery`기능과 `RestTemplate`을 사용해 `ribbon`을 사용해보자.  

### 유레카 서버 설정

ribbon을 떠나 서비스를 등록하기 위한 서버를 설정하자.  
아주 기본적인 설정만 적용한다.  

```conf
spring.application.name=server
server.port=8761
# spring.profiles.active=peer1

# 유레가 서버의 보호모드를 off해 90초동안 인스턴스 유지를 없애고 eviction-interval-timer 기본값인 60초 동안기다리도록 설정
eureka.server.enable-self-preservation=false

# 60초가 너무 길기때문에 3초로 설정
eureka.server.eviction-interval-timer-in-ms=3000
# client 하트비드는 1초마다 도착하고 2초가 지나면 클라이언트의 서비스 지원을 중지하고 하트비트가 오지 않고 3초가 지나면 서비스를 퇴거(삭제)한다

# 시큐리티 설정, eureka name/pw을 알아야 접근 가능하다.
spring.security.user.name=admin
spring.security.user.password=qwer

# 암호를 설정했다면 자신에게도 defaultZone에 계정과 비번을 설정한 url을 지정해야 서버에서 오류가 발생하지 않는다.
# 아무리 fetch, register옵션을 false로 지정해도.... (자기 자신에게도 지속적으로 연결 상태를 체크하기때문)
eureka.client.service-url.defaultZone=http://admin:qwer@localhost:8761/eureka/

# 등록 이후 Instance 정보가 변경 되었을 때 Registry 정보를 갱신하기 위한 REST를 2초마다 호출
eureka.client.instance-info-replication-interval-seconds=2

eureka.client.fetch-registry=false
eureka.client.register-with-eureka=false
```  

메인 클래스는 아래와 같이 설정   
```java
@SpringBootApplication
@EnableEurekaServer
public class EurekaserverApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaserverApplication.class, args);
    }
}
```

유레카 서버에선 `ribbon`으로 인한 추가 변경은 일어나지 않는다.  

### 유레카 클라이언트

이 글의 주제가 서비스(유레카 클라이언트)들 간의 `ribbon`, `RestTemplate`을 사용한 부하분산 처리된 커뮤니케이션이다.  

전체적인 구조는 아래 그림과 같다.  

![ribbon1]({{ "/assets/2019/ribbon1.png" | absolute_url }}){: .shadow}  

모두 유레카 클라이언트 서비스이며 다음과 같이 `application.properties`파일 구성

```conf
eureka.client.service-url.defaultZone=http://admin:qwer@localhost:8761/eureka/
management.endpoint.shutdown.enabled=true
management.endpoint.shutdown.sensitive=false
management.endpoints.web.exposure.include=*
eureka.instance.lease-renewal-interval-in-seconds=1
eureka.instance.lease-expiration-duration-in-seconds=2
eureka.client.register-with-eureka=true
eureka.client.fetchRegistry=true

...

server.port=${PORT:8093}
spring.application.name=product-service

...

spring.application.name=customer-service
server.port=${PORT:8092}

...

spring.application.name=account-service
server.port=${PORT:8091}

...

spring.application.name=order-service
server.port=${RORT:8090}
```

> 중복되거나 부가적인 설정은 생략.  

client4개를 동작시키면 아래 그림과 같이 구성될 것이다.  

![ribbon2]({{ "/assets/2019/ribbon2.png" | absolute_url }}){: .shadow}  

위의 구조 그림을 보면 `order service`에서 기타 3개의 `service`의 REST API를 모두 호출해야 한다.  

이를 위해 `RestTemplate`스프링 빈 객체를 생성하고 각 서비스에 해당하는 `Ribbon Client`를 생성한다.  

```java

@SpringBootApplication
@EnableDiscoveryClient
@RibbonClients({
        @RibbonClient(name = "account-service"),
        @RibbonClient(name = "customer-service"),
        @RibbonClient(name = "product-service")
})
public class OrderApplication {

    @LoadBalanced
    @Bean
    RestTemplate restTemplate() {
        return new RestTemplate();
    }

    public static void main(String[] args) {
        SpringApplication.run(OrderApplication.class, args);
    }
}

```


