---
layout: post
title:  "Data Structures - List2!"
date: 2019-01-18
author: kouzie
categories: DataStructures
tags: C DataStructures 열혈 ArrayBaseList List
cover:  "/assets/instacode.png"
published: true

---

### List자료구조 만들기
List ADT정의했고 main함수까지 만들었다. (Data Structures - List참조)

1. ADT를 근거로 자료구조를 구현한다.
ArrayList.h와 ArrayList.cpp를 구현해보자.

#### ArrayList.h
```
#ifndef __ARRAY_LIST_H__
#define __ARRAY_LIST_H__
#define LIST_LEN 100

typedef int LData;

typedef struct __ArraLiyst
{
    //제목에서 알 수 있듯이 배열을 기반으로 만든 List이다.
    LData arr[LIST_LEN];
    int arrlen;     //리스트에 들어가 있는 데이터 개수(항상 배열의 마지막 인덱스)
    int curPostion; //배열 인덱스로 현재 가리키는 위치 표시
}ArrayList;

typedef ArrayList List;

void ListInit(List* plist);
void LInsert(List* plist, LData data);
int LFirst(List* plist, LData* pdata);
int LNext(List* plist, LData* pdata);
LData LRemove(List* plist);
int LCount(List* plist); 
#endif
```

#### ArrayList.cpp
```
#include <stdio.h>
#include "ArrayList.h"

void ListInit(List* plist)
{
    plist->arrlen = 0;
    plist->curPostion = -1;
}

void LInsert(List* plist, LData data)
{
    if(plist->arrlen >= LIST_LEN)
    {
        printf("Over Array Length %d\n", plist->arrlen);  
    }
    plist->arr[plist->arrlen++] = data;
}

int LFirst(List* plist, LData* pdata)
{
    if(plist->arrlen ==0) //list안에 data가 없을경우
    {
        printf("LFirst Error %d\n", plist->arrlen);
        return 0;
    }
    *pdata = plist->arr[0];
    plist->curPostion = 1;
    return 1;
}

int LNext(List* plist, LData* pdata)
{
    if(plist->curPostion >= plist->arrlen)
    {
        printf("LNext Error %d\n", plist->curPostion);
        return 0;
    }
    *pdata = plist->arr[plist->curPostion++];
    return 1;
}
LData LRemove(List* plist)
{
    LData rdata = plist->arr[plist->curPostion-1];
    
    for(int i = plist->curPostion-1; i < plist->arrlen; i++)
    {
        plist->arr[i] = plist->arr[i+1];
    }//leftShift
    //중간값 삭제시 뒤의 데이터를 모두 한칸씩 땡겨야한다. 
    plist->arrlen--;
    plist->curPostion--;
    return rdata;
}
int LCount(List* plist)
{
    return plist->arrlen;
}
```

LRemove함수는 보면 약간 불편감을 느낄 수 있다. 배열이 길면 길수록 앞쪽의 데이터를 삭제시 땡겨와야할 데이터가 많아진다.  

따라서 List는 보통 배열로 구현하지 않고 포인터를 활용한 연결 방식의 리스트로 구현한다.