---
title:  "Data Structures - List3!"
read_time: false
share: false
toc: true
author_profile: false


categories:
  - DataStructures
tags:
  - C
  - DataStructures
  - 열혈
  - List
---

```
typedef struct __ArrayList
{
    LData arr[LIST_LEN];
    int arrlen;     //리스트에 들어가 있는 데이터 개수(항상 배열의 마지막 인덱스)
    int curPostion; //배열 인덱스로 현재 가리키는 위치 표시
}ArrayList;
```
요로코롬 생겼던 Array기반 List를 포인터를 사용한 연결기반 리스트로 만들거다.
참고로 ADT를 다시 정의할 필요는 없다. Array기반이던 Linked기반이던 List가 하는 역할은 똑같다.


Linked List가 어떻게 생겼는지 그림으로 그리면 다음과 같다.

![LinkedList]({{ "/assets/DataStructure/linkedlist.png" | absolute_url }})

보통 그림의 "네모"를 노드라 부르고 노드안은 다음과 같이 구성될거다.  
데이터를 저장할 int형 변수 하나, 다음 노드를 가리킬 포인터 하나.  
```
typdef struct _node
{
    int data;
    struct _node* next;
}Node;
```

그럼 여러개의 노드로 구성된 Linekd List를 구현해보자
```
typedef struct _linkedList
{
    Node* head;
    Node* cur;
    Node* before;
    int numOfData;
}LinkedList;
```

head는 첫 Node를 항상 가리키고 있고 cur는 현재 가리키는 노드 포인터, before는 나중에 Node삭제후 cur가 삭제된 노드의 전을 가리키기 위한
백업용도로 사용하는 포인터, numOfData는 노드개수이다.

![LinkedList2]({{ "/assets/DataStructure/linkedlist2.png" | absolute_url }})
대충 이런식으로 구성될 것이다.

이 경우 노드 추가를 할때 어떻게 추가해야 할까?
cur의 뒤에 추가하는것 좋지 않다. cur는 리스트를 이리저리 이동하는 포인터이기에 항상 리스트 끝에 위치하진 않는다.

추가하려면 tail이라는 항상 끝부분을 가리키는 포인터를 두어 추가시키던가 head에서 추가시키면 된다(앞부분에 추가).  

tail에 새노드를 추가하는것이 직관적으로 생각할수 있겠지만 tail변수 관리가 귀찮다.  
노드 추가시 tail을 뒤로 옮기는것, 끝부분 노드 삭제시 tail을 앞으로 땡기는것.  

반면 head에서부터 새 노드를 추가하면 tail을 쓰지 않아도 운용 가능하다. 
단 데이터들이 거꾸로 저장된다. 1~N순으로 저장시 N~1순으로 꺼내올 수 있다. 그리고 tail이 있으면 정방향, 역방향 출력이 가능하다.

둘다 단점과 장점이 있음으로 상황에 맞춰 쓰면 좋지만 개인적으로 head에 추가하는게 코드도 짧아지고 생각할 것도 적어지는듯....

그리고 head에 추가하며 생기는 단점들은 Circle Linked List나 Double Linked List로도 해결 가능함으로 헤드에 추가하는게 좋다고 생각한다.

```
/*** 노드의 추가과정 ***/
newNode = (Node*)malloc(sizeof(Node));
newNode->data = readData;
newNode->next = NUL
if(head == NULL) //추가할때 마다 항상 head가 NULL인지 검사.
{
    head = newNode;
}
else
{
    newNode->next = head;
	head = newNode;
}
	
```
newNode는 head가 가리키고 있던 노드를 가리키고, head도 newNode로 가리키는 위치를 옮긴다.

`if(head == NULL) //추가할때 마다 항상 head가 NULL인지 검사.`
추가할때 마다 위의 코드를 수행하지 않도록 하는 방법이 있다.

head에 더미노드를 하나 생성하고 더미노드에서부터 새 노드를 추가시켜주면 된다!
글로보면 이해가 안되니 그림과 코드를 같이봐야한다.
![LinkedList2]({{ "/assets/DataStructure/linkedlist3.png" | absolute_url }})

```
void LInit(List* plist)
{
    plist->head = (Node*)malloc(sizeof(Node));
    plist->head->data = -1;
    plist->head->next = NULL;
    plist->numOfData = 0;
}
```
보면 맨처음 list초기화시 더미노드를 하나 만들고 시작한다.

```
void LInsert(List* plist, LData data)
{
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = plist->head->next;

    plist->head->next = newNode;
    plist->numOfData++;
}
```
그리고 새노드가 추가될땐 항상 head의 더미노드가 앞에 가리키고있던걸 가리키고  
더미노드는 새로운 노드를 가리키게하면 된다.
위의 과정과 비교해서 코드가 훨씬 간결해 졌다.

앞으로 배울 Circle linkedList나 Double LinkedList에서도 이런식으로 더미노드를 적극 활용할 예정이다.

그럼 DummyLinkedList.c 뜯어보며 초기화와 LInsert외에 어떤 함수가 있는지 알아보자.
```

int LFirst(List* plist, LData* data)
{
    if(plist->head->next == NULL)
    {
        printf("LFirst Error\n");
        return FALSE;
    }
    plist->before = plist->head;
    plist->cur = plist->head->next;
    *data = plist->cur->data;
    return TRUE;
}
int LNext(List* plist, LData* data)
{
    if(plist->cur->next == NULL)
    {
        printf("LNext Error\n");
        return FALSE;
    }
    plist->before = plist->cur;
    plist->cur = plist->cur->next; //현재의 cur는 이미 참조했다고 치고 다음 데이터를 참조하기 때문에
    *data = plist->cur->data;
    return TRUE;
}
```
둘다 함수 구조가 비슷하다. LFirst에선 첫 노드를 cur가 가리킬수 있도록 하는 함수임으로 before는 더미노드를, cur는 더미앞의 노드를 가리킨다.  
LNext에선 cur를 한칸씩 이동하며 다음노드의 값을 data에 값을 집어넣는 함수이다. cur를 옮기기전에 before를 cur위치로 먼저 옮겨주자.  
``` 
LData LRemove(List* plist)
{
    LData rdata = plist->cur->data;
    plist->before->next = plist->cur->next;
    free(plist->cur);
    plist->cur = plist->before;
    plist->numOfData--;
    return rdata;
}
```
무작적 현재 가리키는 노드를 삭제(free)시키기전 해야할 과정이 있다. 삭제시키기 전 노드와 앞 노드와의 연결을 유지시켜야한다.  
`plist->before->next = plist->cur->next;`
