---
title:  "객체지향 - 기본개념!"

read_time: false
share: false
author_profile: false
classes: wide

categories:
  - 객체지향

tags:
  - 오브젝트


toc: true

---

## 상속(inheritance)

객체지향에서 상속은 매우 자주 나오는 용어로 코드 재사용을 위해 흔히 사용되는 개념이다.  

상속이란 언어 때문에 아래처럼 상속관계를 오해하기 쉽다.  

![object1]({{ "/assets/2019/object1.jpg" | absolute_url }})  

위 사진은 has-a 관계같이 상속관계와는 잘 어울리지 않는 모델이다.  

우리가 java에서 상속이라 표현하는 모델은 아래 사진과 더 유사하다.  

![object2]({{ "/assets/2019/object2.jpg" | absolute_url }})  

즉 상속은 확장, 포함, 분류의 개념이라 할 수 있다.  

java에서 `inheritance`키워드 대신 `extends`키워드를 사용하는 것이 이때문이다.  

> 흔히 상속을 `is-a` 관계라 표현하는데 좀더 명확한 표현은 `is a kind of`관계라 할 수 있다.  - Three Amigos

## 인터페이스  

다중상속이 안되는 java에서 좀더 효율적으로 코드 재사용을 하기 위해 나온것이 인터페이스  

인터페이스와 이를 구현하는 클래스와의 관계는 `is-a`관게도 `is a kind of`아닌 `is able to`관계이다.  

즉 무엇을 할 수 있는 지에 대한 명세가 인터페이스라 할 수 있다.  

> `Serializable`, `Cloneable`, `Comparable`, `Runnable` 등 java 기존의 여러 인터페이스 뒤에 able이란 스펠이 붙는 이유도 위와 같다.  

> 캡슐화, 추상화, 다형성에 대한 내용은 생략



## 결합도와 응집도

좋은 소프트웨어는 낮은 결합도, 높은 응집도를 요구한다.  

결합도는 객체간 의존정도를 나타내고 결합도를 낮추면 의존성도 줄어들고 객체의 재사용, 수정, 유지보수가 용이해진다.  

**SOLID**를 통해 어떻게 낮을 결합도, 높은 응집도를 구현하는지 알아보자.  

## SOLID - 객체지향 설계 5원칙

### SRP - (단일책임 원칙: Single Responsibility Principle)

우리는 모두 책임을 가지고 생활한다.  
학생의 책임은 공부, 군인의 책임은 방호, 개발자의 책임은 개발이다.  

개발자 종류도 여러가지가 있다,  
`웹개발`, `시스템개발`, `모바일개발`, `임베디드개발` 등등...

위의 각종 개발을 모두 할 수 있는 개발자가 있을 수도 있지만 거의 없다.  
만약 `개발자`란 클래스를 만들 때 클래스 설계를 위의 모든 개바을 할수 있도록 설계할 것인가?  

아니면 각종 종류별로 `개발자`클래스를 설계할 것인가?  

당연히 후자가 좋다.  

만약 `시스템 개발자` 중에서도 리눅스 시스템인지, 윈도우 시스템인지 또 다른 별도의 `개발자` 클래스를 설계해야 한다면?  

후자로 설계했다면 상속 한번으로 시스템 개발에 대한 포괄적인 메서드는 모두 재사용 가능하지만  
전자로 설계했다면 상속보다는 새로운 `윈도우 시스템 개발자`를 설계 해야 한다.  

개발을 오래한 사람이라면 `윈도우 시스템 개발`도 하면서 `안드로이드 모바일 개발`도 할 수 있는 개발자가 있을 것이다.  
자바에선 다중 상속이 불가함으로 사실 위의 모든 개발자 종류는 클래스로 설계하기 보단 인터페이스로 설계하는 것이 옳다.  

즉 객체지향 개발을 하려면 어느정도까지 추상화를 통해 인터페이스로 구현할 것인지,  
어디서 부턴 인터페이스들을 구현한 클래스를 설계할 것인지  
효율적인 결정이 필요하다.  

앞으로 `interface`, `abstract class`, `class` 상관 없이 최소한의 책임을 가지는 엔티티로 설계하자.  

### OCP - (개방폐쇄 원칙: Open Close Principle)


> 소프트웨어 엔티티는 확장에 대해 열려있어야 하지만 변경에 대해서는 닫혀이어야 한다.  

OCP를 가장 잘 구현한 예는 JDBC이다.  

Oracle, Mysql, MS-sql 등 어떤 데이터 베이스 이던간에 Connection 부분만 별도의 라이브러리로 설정하고 연결하면  
그 뒤의 sql문을 실행하고 결과값을 가져오는 과정은 모두 똑같다.  

JDBC뿐 아니라 JPA, Mybatis등에서도 OCP 의 예를 들 수 있다.  

즉 OCP를 잘 구현하려면 모든 엔티티가 기본적으로 가지고 있는 행위를 인터페이스로 구현하는 것이 중요하다.  

### LSP - (리스코브 치환의 원칙: The Liskov Substitution Principle)

리스코브는 바바라 리스코프란 사람이 만들었기 때문에 붙은 스펠이다.  

위에서 상속과 인터페이스는 `is a kind of`, `is able to`관계를 가져야 한다 말했는데  
위의 두 관계대로 프로그램 개발을 했다면 이미 LSP를 잘 구현한 것이다.  

자바에서의 다운 캐스팅, 업 캐스팅은 LSP를 기반으로 이루어진다.  
상위(부모) 클래스는 하위(자식)클래스인척 할 수 있다.  
하위(자식) 클래스는 상위(부모)클래스의 메서드를 호출할 수 있고 논리적으로 이상하지 않고  
상위 클래스의 메서드에서 기능이 더 추가되어야지 삭제될 수 는 없다.  

### ISP - (인터페이스 분리 원칙: Interface Segregation Principle)

위에서 상위 클래스는 기능이 풍성할 수록 좋고, 인터페이스는 작을 수록 좋다 하였다.  

ISP는 인터페이스를 최소한의 기능을 가지도록 설계하는 것을 뜻한다.  

인터페이스에 기능을 적게 넣으면 만들어진 객체의 기능을 제한할 수 도 있다.  

`class 사람 implements 군인{...}` 이란 클래스가 정의되어 있다면  
`군인 홍길동 = new 사람();` 으로 사람 인스턴스를 생성하자.  

`홍길동` 객체를 통해서 호출할 수 있는건 `군인`인터페이스에 정의된 추상메서드 뿐이다.  

SRP에선 클래스의 단일책임을, ISP에선 인터페이스의 단일 책임을 요구한다.  
만약 최소한의 기능이지만 많은 기능이 들어갈 수 밖에 없다면 인터페이스 보단 SRP를 따라 클래스로 만드는 것이 좋다.

즉 하나의 엔티티를 여러개의 엔티티로 쪼갤 수 있다면 ISP를  
하나의 엔티티를 쪼갤 수 없고, 쪼갠다 하더라도 많은 기능이 포함된다면 SRP이다.  

어디까지는 인터페이스로 설계하고 어디까지는 클래스로 설계하는 지에 대한 경계를 정할 수 있다!
(대부분이 SRP 로 진행된다.)

### DIP - (의존역전 원칙: Dependency Inversion Principle)

객체가 의존관계를 가질때 최대한 상위클래스, 추상클래스, 인터페이스를 의존하도록 하는 법칙
상위 클래스일 수록 변할 가능성이 적기 때문에 의존관계를 갖는 객체또한 영향을 받는 가능성이 적어진다.  

만약 하위클래스를 의존하게 된다면 하위클래스가 계속 변함에 따라 오히려 서로 의존하는 관계가 될 수 있다.  
이를 의존 역전 원칙이라 한다.  


